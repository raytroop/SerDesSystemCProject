# EyeAnalyzer Module Technical Documentation

ðŸŒ **Languages**: [ä¸­æ–‡](../../modules/EyeAnalyzer.md) | [English](EyeAnalyzer.md)

---

**Level**: Python Analysis Component  
**Class Name**: `EyeAnalyzer`  
**Current Version**: v1.0 (2026-01-23)  
**Status**: Production Ready

---

## 1. Overview

### 1.1 Design Principles

EyeAnalyzer is a Python post-processing component of the SerDes link simulation system. Based on statistical signal processing theory, it performs eye diagram construction and jitter decomposition on waveform data generated by SystemC-AMS. Its core design concept is to transform time-domain waveforms into phase-amplitude two-dimensional probability density distributions, extract eye diagram geometric parameters through density matrices, and use the dual-Dirac model to separate random jitter and deterministic jitter components.

This module adopts a modular pipeline architecture, supports both file and memory data input modes, and provides rich configuration parameters to adapt to different link rates and signal quality scenarios. The design goal is to achieve high-performance batch processing capability while ensuring analysis accuracy.

### 1.2 Core Features

- **Multi-dimensional Eye Diagram Analysis**: Supports extraction of geometric parameters such as eye height, eye width, opening area, and linearity error
- **Jitter Decomposition Engine**: Implements RJ/DJ/TJ@BER precise decomposition based on the dual-Dirac model
- **Flexible Sampling Strategies**: Supports three phase estimation methods: peak sampling, zero-crossing sampling, and phase-lock
- **High-Performance Computing**: Based on NumPy vectorized operations, supports analysis of tens of millions of UI datasets
- **Multi-format Output**: Generates JSON metrics, PNG/SVG eye diagrams, and CSV auxiliary data
- **Robustness Design**: Comprehensive boundary condition handling and error diagnosis mechanisms
- **Test-Driven**: Built-in 6 major test scenarios, supporting regression verification and performance benchmark testing

### 1.3 Version History

| Version | Date | Major Changes |
|---------|------|---------------|
| v1.0 | 2026-01-23 | Initial version, complete eye diagram analysis and jitter decomposition functionality |

## 2. Module Interface

### 2.1 Port Definitions (Python Interface)

As a Python analysis component, EyeAnalyzer's "ports" correspond to function input/output interfaces, supporting file and memory data interaction modes.

| Port Name | Direction | Type | Description |
|-----------|-----------|------|-------------|
| `dat_path` | Input | str | Waveform data file path (tabular format output by SystemC-AMS) |
| `waveform_array` | Input | numpy.ndarray | In-memory waveform array (alternative to file input), shape: (N, 2), columns: time, value |
| `ui` | Input | float | Unit Interval (UI, seconds), used for phase normalization |
| `clk_params` | Input | dict | Clock parameters (optional), including sampling phase estimation method, etc. |
| `metrics_json` | Output | str | Eye diagram metrics JSON file path (default: `eye_metrics.json`) |
| `eye_image` | Output | str | Eye diagram visualization image file path (PNG/SVG format) |
| `csv_data` | Output | str | Auxiliary analysis data CSV file path (PSD/PDF/two-dimensional density) |

> **Important**: `dat_path` and `waveform_array` are mutually exclusive inputs; exactly one must be provided; all output file paths can be customized through parameter configuration.

### 2.2 Parameter Configuration

#### Basic Parameters

| Parameter Name | Type | Default Value | Description |
|----------------|------|---------------|-------------|
| `ui_bins` | integer | 128 | Eye diagram horizontal direction (time axis) resolution, i.e., the number of histogram bins within a unit interval |
| `amp_bins` | integer | 128 | Eye diagram vertical direction (amplitude axis) resolution, i.e., the number of histogram bins within the amplitude range |
| `measure_length` | double | 1e-4 | Statistical duration (seconds), used to truncate the latter segment of waveform data for eye diagram analysis to ensure data stability |
| `target_ber` | double | 1e-12 | Target bit error rate, used to calculate TJ@BER (Total Jitter at Target BER) |
| `ui` | double | **Required** | Unit interval (seconds), determined by link rate (e.g., 10Gbps corresponds to 2.5e-11s) |
| `sampling` | string | 'phase-lock' | Sampling phase estimation strategy: 'peak' (peak sampling), 'zero-cross' (zero-crossing sampling), 'phase-lock' (phase lock) |

#### Advanced Parameters

| Parameter Name | Type | Default Value | Description |
|----------------|------|---------------|-------------|
| `hist2d_normalize` | boolean | true | Whether to normalize the 2D histogram to probability density (PDF) |
| `psd_nperseg` | integer | 16384 | Number of samples per segment for PSD calculation (affects frequency resolution) |
| `jitter_extract_method` | string | 'dual-dirac' | Jitter decomposition method: 'dual-dirac' (dual-Dirac model), 'tail-fit' (tail fitting) |
| `linearity_threshold` | double | 0.1 | Amplitude threshold for linearity error calculation (analyzes only the eye diagram opening region) |

#### Output Control Parameters

| Parameter Name | Type | Default Value | Description |
|----------------|------|---------------|-------------|
| `output_image_format` | string | 'png' | Output image format: 'png', 'svg', 'pdf' |
| `output_image_dpi` | integer | 300 | Image resolution (DPI) |
| `save_csv_data` | boolean | false | Whether to save auxiliary analysis data (PSD, PDF, 2D density matrix) |
| `csv_data_path` | string | 'eye_analysis_data' | CSV data output directory path |

## 3. Core Implementation Mechanisms

### 3.1 Signal Processing Flow

EyeAnalyzer adopts a multi-stage pipeline processing architecture. The complete processing flow from raw waveform data to eye diagram metrics and jitter decomposition results is as follows:

```
Data Loading â†’ Waveform Truncation â†’ Phase Estimation â†’ Phase Normalization â†’ 2D Histogram Construction â†’ Eye Diagram Metric Extraction â†’ Jitter Decomposition â†’ Result Output
```

**Step 1 - Data Loading**: Read waveform data from the SystemC-AMS tabular format file specified by `dat_path` or from the `waveform_array` memory array. Input data must contain two columns: time (seconds) and signal amplitude (volts). If clock parameters are provided, phase-lock mode is entered.

**Step 2 - Waveform Truncation**: Truncate the latter segment of waveform data for eye diagram analysis according to the `measure_length` parameter. This step ensures using data from after the link has stabilized for statistics, avoiding the impact of startup transient processes on eye diagram quality assessment. The truncation start point is `t_start = t_total - measure_length`.

**Step 3 - Phase Estimation**: Estimate the optimal sampling phase using the configured sampling strategy (`sampling` parameter). Available strategies include:
- **Peak Sampling** (`peak`): Sample at signal amplitude peaks to maximize signal-to-noise ratio
- **Zero-Crossing Sampling** (`zero-cross`): Sample at signal zero-crossing points, suitable for clock recovery verification
- **Phase-Lock** (`phase-lock`): Calculate ideal sampling phase based on clock parameters, recommended by default

**Step 4 - Phase Normalization**: Convert absolute time to normalized phase `phi = (t % UI) / UI`, where UI is the unit interval. This step maps waveform points from different moments to relative positions within the [0, 1] interval, achieving eye diagram period alignment and overlay.

**Step 5 - 2D Histogram Construction**: Use `numpy.histogram2d` to build a 2D histogram on the phase axis (`ui_bins`) and amplitude axis (`amp_bins`). If `hist2d_normalize` is enabled, normalize the count values to probability density function (PDF), generating the eye diagram density matrix `H[phi, amplitude]`.

**Step 6 - Eye Diagram Metric Extraction**: Calculate core eye diagram metrics from the 2D density matrix:
- **Eye Height**: Vertical opening distance between upper and lower eye boundaries at the optimal sampling phase
- **Eye Width**: Horizontal opening distance between left and right crossing points at the optimal decision threshold
- **Opening Area**: Integral area of the eye diagram opening region, comprehensively reflecting eye diagram quality
- **Linearity Error**: Linear fitting of the eye diagram opening region, calculating fitting error

**Step 7 - Jitter Decomposition**: Decompose jitter components using the dual-Dirac model or tail-fit method:
- **Random Jitter (RJ)**: Gaussian distribution, extracting standard deviation `rj_sigma` through statistical characteristics of the eye diagram crossing region
- **Deterministic Jitter (DJ)**: Data-dependent jitter and periodic jitter, extracting peak-to-peak value `dj_pp` through bimodal distribution separation
- **Total Jitter (TJ@BER)**: At the target bit error rate `target_ber`, the convolution result of RJ and DJ

**Step 8 - Result Output**: Save calculated metrics as structured outputs:
- **JSON File**: `metrics_json` contains all eye diagram metrics and jitter decomposition results
- **Image File**: `eye_image` generates eye diagram visualization image (PNG/SVG/PDF)
- **CSV Data** (optional): `csv_data` saves PSD, PDF, and 2D density matrix for in-depth analysis

### 3.2 Key Algorithms/Mechanisms

#### 3.2.1 Eye Diagram Construction Algorithm

The core of eye diagram construction lies in **phase mapping** and **2D density calculation**:

**Phase Mapping Mathematical Expression**:
```
phi(t) = (t mod UI) / UI,  phi âˆˆ [0, 1]
```
Where `UI = 1 / data_rate`, `data_rate` is the link data rate (e.g., 10Gbps corresponds to UI = 2.5e-11s).

**2D Histogram Construction**:
```python
H, xedges, yedges = np.histogram2d(phi, amplitude, 
                                   bins=[ui_bins, amp_bins], 
                                   density=hist2d_normalize)
```
- `H`: Eye diagram density matrix, shape `(ui_bins, amp_bins)`
- `xedges`: Phase axis boundary array, length `ui_bins + 1`
- `yedges`: Amplitude axis boundary array, length `amp_bins + 1`

**Density Visualization**:
Use `matplotlib.imshow` to render the density matrix as a heatmap, with color mapping using `'hot'` or `'viridis'` schemes, where color intensity corresponds to the probability density of signal occurrence.

#### 3.2.2 Eye Diagram Metric Calculation Algorithm

**Eye Height Calculation**:
Eye height is defined as the vertical distance between upper and lower eye boundaries at the optimal sampling phase `phi_opt`:
```
eye_height = V_top(phi_opt) - V_bottom(phi_opt)
```
Where `V_top` and `V_bottom` are determined by finding the 50% amplitude points of the upper and lower edges in the density matrix.

**Eye Width Calculation**:
Eye width is defined as the horizontal distance between left and right crossing points at the optimal decision threshold `V_th`:
```
eye_width = phi_right(V_th) - phi_left(V_th)
```
Crossing point positions are determined by detecting the left and right boundaries of the eye diagram opening in the density matrix, typically using 50% amplitude as the threshold.

**Opening Area Calculation**:
Opening area is obtained by integrating the probability density within the eye diagram opening region:
```
eye_area = âˆ«âˆ«_EyeOpening H(phi, V) dphi dV
```
Discrete implementation sums the density values of all bins within the opening region, multiplied by the bin area `(Î”phi Ã— Î”V)`.

**Linearity Error Calculation**:
Perform linear regression on data points within the eye diagram opening region, calculating fitting residuals:
```
linearity_error = RMS( V_actual - V_linear_fit )
```
This metric reflects the linearity of signal transmission; the smaller the value, the smaller the signal distortion.

#### 3.2.3 Jitter Decomposition Algorithm

**Dual-Dirac Model**:
The dual-Dirac model models the jitter distribution as the convolution of two Dirac functions, corresponding to the distributions of data "0" and "1" respectively:

```
PDF_total(t) = 0.5 Ã— [PDF_0(t) + PDF_1(t)]
```

Where `PDF_0` and `PDF_1` are Gaussian distributions:
```
PDF_0(t) = (1 / (Ïƒ_RJ Ã— âˆš(2Ï€))) Ã— exp(-(t - Î¼_0)Â² / (2Ïƒ_RJÂ²))
PDF_1(t) = (1 / (Ïƒ_RJ Ã— âˆš(2Ï€))) Ã— exp(-(t - Î¼_1)Â² / (2Ïƒ_RJÂ²))
```

**Parameter Extraction**:
- **RJ Standard Deviation**: Extract `Ïƒ_RJ` by fitting a Gaussian distribution to the width of the distribution in the eye diagram crossing region
- **DJ Peak-to-Peak**: `dj_pp = Î¼_1 - Î¼_0`, i.e., the distance between the means of the two distributions
- **TJ@BER Calculation**: At the target bit error rate BER, total jitter is the convolution of RJ and DJ:
  ```
  tj_at_ber = dj_pp + 2 Ã— Q(ber) Ã— Ïƒ_RJ
  ```
  Where `Q(ber)` is the Q function; at BER = 1e-12, `Q â‰ˆ 7.03`.

**Tail-Fit Method** (optional):
Perform exponential fitting on the tails of the eye diagram crossing region to separate RJ and DJ components. Suitable for cases with non-Gaussian jitter distributions, but with higher computational complexity.

#### 3.2.4 PSD/PDF Calculation Methods

**Power Spectral Density (PSD)**:
Calculate the power spectral density of the signal using Welch's method:
```python
f, Pxx = signal.welch(amplitude, fs=Fs, nperseg=psd_nperseg)
```
- `Fs`: Sampling rate, automatically calculated from the time step of the waveform data
- `nperseg`: Number of samples per segment, controls frequency resolution
- `Pxx`: Power spectral density (VÂ²/Hz)

**Probability Density Function (PDF)**:
Estimate the probability density distribution of signal amplitude using histogram:
```python
pdf, bins = np.histogram(amplitude, bins=256, density=True)
```
`density=True` ensures normalization to probability density (integral area is 1).

### 3.3 Design Decision Explanations

#### 3.3.1 Why `phase-lock` is the Default Sampling Strategy

**Design Considerations**:
- **Clear Physical Meaning**: The `phase-lock` strategy calculates the ideal sampling phase based on link clock parameters, consistent with the behavior of actual CDR (Clock Data Recovery) circuits
- **Strong Robustness**: Compared to `peak` and `zero-cross` strategies, `phase-lock` is less sensitive to noise and distortion, remaining stable even when signal quality is poor
- **Consistent with Engineering Practice**: In real SerDes systems, the sampling phase is fixed after CDR locking at the receiver; `phase-lock` simulates this behavior

**Trade-off Analysis**:
- `peak` strategy performs optimally at high SNR but is sensitive to amplitude noise
- `zero-cross` strategy is suitable for clock recovery verification but not for data sampling
- `phase-lock` achieves the best balance between comprehensive performance and robustness, hence as the default strategy

#### 3.3.2 Why Use 2D Histogram Instead of Point-by-Point Plotting

**Performance Advantages**:
- **High Computational Efficiency**: 2D histogram completes statistics for all points at once through `numpy.histogram2d`, with time complexity O(N), while point-by-point plotting has time complexity O(N Ã— rendering overhead)
- **Low Memory Footprint**: Histogram matrix size is fixed at `ui_bins Ã— amp_bins`, independent of input data volume; point-by-point plotting requires storing coordinate information for all points

**Statistical Characteristics**:
- **Probability Density Visualization**: 2D histogram naturally supports density normalization, where color intensity directly reflects the probability of signal occurrence, consistent with the statistical nature of eye diagrams
- **Noise Suppression**: Through binning operations, histograms have a natural smoothing effect on high-frequency noise, making eye diagram contours clearer

**Scalability**:
- **Dynamic Resolution Adjustment**: By adjusting `ui_bins` and `amp_bins` parameters, flexible trade-offs between computational accuracy and performance can be achieved
- **Backend Independent**: 2D density matrices can be easily exported to multiple visualization backends (matplotlib, Plotly, Surfer, etc.), maintaining data consistency

#### 3.3.3 Why Adopt the Dual-Dirac Model for Jitter Decomposition

**Model Rationality**:
- **Solid Physical Foundation**: The dual-Dirac model stems from the physical essence of high-speed digital communications; the transmission timing of data "0" and "1" follows Gaussian distributions, consistent with the Central Limit Theorem
- **Industry Standard**: In high-speed interface standards such as IEEE 802.3 and OIF-CEI, the dual-Dirac model is the recommended jitter decomposition method, with broad recognition and comparability

**Computational Simplicity**:
- **Few Parameters**: Only need to extract RJ standard deviation and DJ peak-to-peak value, low computational complexity
- **Analytical Solution**: TJ@BER can be directly calculated through the Q function, without numerical integration or iteration, high execution efficiency

**Engineering Practicality**:
- **Directly Related to Eye Diagram**: Parameters of the dual-Dirac model can be directly extracted from the eye diagram crossing region, simple and intuitive to implement
- **BER Extrapolation Capability**: Based on the Gaussian distribution characteristics of RJ, total jitter at low BER (e.g., 1e-12) can be accurately extrapolated, meeting system specification verification requirements

**Limitations**:
- The dual-Dirac model assumes Gaussian jitter distribution; for strongly non-Gaussian jitter (such as periodic jitter caused by power supply noise), accuracy may decrease
- Can switch to `tail-fit` method at this time, but need to trade off increased computational complexity

#### 3.3.4 Why the `measure_length` Parameter is Needed to Truncate the Latter Segment of Waveform

**Transient Process Exclusion**:
- **Link Startup Phase**: SerDes links have transient processes such as CDR locking and adaptive equalization convergence during startup, with unstable signal quality
- **CTLE/DFE Convergence**: Adaptive algorithms at the receiver need time to converge to optimal coefficients; early eye diagrams do not reflect true performance

**Statistical Stability**:
- **Law of Large Numbers**: Eye diagram analysis is based on statistical methods, requiring a sufficient number of UI samples to ensure metric convergence and stability
- **Truncation Error Control**: By truncating the latter segment of data, analysis can be ensured based on waveforms after the link has stabilized, avoiding statistical bias introduced by transient processes

**Consistent with Engineering Practice**:
- **Consistent with Test Specifications**: In chip testing and verification, eye diagram measurements are typically performed after the link has stabilized; the `measure_length` parameter simulates this test process
- **Debugging Friendly**: When debugging links, different time periods of signal quality changes can be observed by adjusting `measure_length` to locate locking or convergence issues

**Parameter Selection Suggestions**:
- `measure_length` should contain at least 10,000 UI, recommended 100,000 UI or more
- For example, for a 10Gbps link (UI = 2.5e-11s), 100,000 UI corresponds to 2.5e-6s, setting `measure_length = 2.5e-6` can obtain stable statistical results

## 4. Test Platform Architecture

### 4.1 Test Platform Design Philosophy

As a Python analysis component, EyeAnalyzer's test platform is built using the **pytest** framework, following Python testing best practices. Core design concepts include:

1. **Layered Testing Strategy**: Establish a four-layer system of unit tests, integration tests, regression tests, and performance tests to ensure full coverage verification from algorithm modules to complete analysis processes
2. **Data-Driven Testing**: Use YAML/JSON format to define test cases, achieving separation of test data and test logic for easy expansion and maintenance
3. **Simulated Data Generation**: Built-in high-fidelity waveform generator, supporting PRBS sequences, jitter injection, channel impairment and other features to ensure test controllability and repeatability
4. **Automated Verification**: Integrate reference metric calculators and result comparison tools to achieve automatic verification of test results, reducing manual intervention
5. **Performance Benchmarks**: Establish performance test suites to monitor analysis speed and memory usage, preventing performance degradation caused by code regressions

Unlike SystemC-AMS module testing, EyeAnalyzer's test platform is entirely based on the Python ecosystem, using pytest's fixture mechanism for flexible composition and reuse of test components.

### 4.2 Test Scenario Definitions

The test framework supports the following core test scenarios:

| Scenario Name | Command Line Parameter | Test Objective | Output Files |
|---------------|------------------------|----------------|--------------|
| BASIC_EYE_ANALYSIS | `basic` / `0` | Basic eye diagram metric calculation and visualization | test_basic_eye.png, metrics.json |
| JITTER_DECOMPOSITION | `jitter` / `1` | Jitter decomposition accuracy verification | test_jitter_decomp.png, jitter_stats.json |
| SAMPLING_STRATEGY | `sampling` / `2` | Comparison of different sampling strategies | sampling_comparison.png, strategy_metrics.json |
| PERFORMANCE_STRESS | `perf` / `3` | Large data volume performance benchmark testing | performance_report.json, memory_profile.dat |
| BOUNDARY_CONDITION | `boundary` / `4` | Boundary conditions and exception handling | boundary_test_report.json |
| REGRESSION_VALIDATION | `regression` / `5` | Verification against reference results | regression_report.html, diff_metrics.json |

### 4.3 Scenario Configuration Details

#### 4.3.1 Basic Eye Diagram Analysis Test (BASIC_EYE_ANALYSIS)

**Scenario Description**:
Verify EyeAnalyzer core functionality, extracting basic eye diagram geometric parameters such as eye height, eye width, and opening area from standard PRBS-31 waveform data. This scenario is used to confirm the correctness of the basic signal processing flow and metric calculation accuracy.

**Input Data Characteristics**:
- Data Type: PRBS-31 pseudo-random sequence
- Data Rate: 10 Gbps (UI = 2.5e-11s)
- Sampling Points: 100,000 UI (total duration 2.5e-6s)
- Signal Amplitude: Differential swing 800mV
- Noise: Gaussian white noise, Ïƒ = 5mV

**Parameter Configuration**:
```yaml
eye:
  ui_bins: 128
  amp_bins: 128
  measure_length: 2.5e-6
  target_ber: 1e-12
  sampling: phase-lock
  ui: 2.5e-11
```

**Verification Points**:
- Eye height should be close to input swing (800mV Â± 10%)
- Eye width should be close to 1 UI (2.5e-11s Â± 5%)
- Opening area > 0.5 Ã— (eye height Ã— eye width)
- Linearity error < 5% (reflects signal distortion level)

**Expected Results**:
- Eye Height: ~750mV
- Eye Width: ~0.95 UI
- RJ_sigma: ~5e-12s (consistent with injected noise)
- DJ_pp: ~1e-11s (PRBS-31 data-dependent jitter)

#### 4.3.2 Jitter Decomposition Accuracy Test (JITTER_DECOMPOSITION)

**Scenario Description**:
Verify the accuracy and consistency of the RJ/DJ/TJ jitter decomposition algorithm. Evaluate decomposition result accuracy by injecting known amounts of random jitter and deterministic jitter.

**Input Data Characteristics**:
- Base Data: PRBS-15 sequence
- Random Jitter: RJ_sigma = 10e-12s (Gaussian distribution)
- Deterministic Jitter: DJ_pp = 20e-12s (sinusoidal modulation)
- Periodic Jitter: PJ_freq = 5MHz, PJ_pp = 5e-12s
- Total Duration: 5e-6s (200,000 UI)

**Parameter Configuration**:
```yaml
eye:
  ui_bins: 256
  amp_bins: 256
  measure_length: 5e-6
  target_ber: 1e-12
  jitter_extract_method: dual-dirac
  sampling: phase-lock
  ui: 2.5e-11
```

**Verification Points**:
- Extracted RJ_sigma deviation from injected value < 15%
- Extracted DJ_pp deviation from injected value < 10%
- TJ@BER calculation conforms to theoretical formula: TJ = DJ + 2 Ã— Q(BER) Ã— RJ
- Results converge under different measure_length (variation < 5%)

**Expected Results**:
- RJ_sigma: ~10e-12s (Â±1.5e-12s)
- DJ_pp: ~20e-12s (Â±2e-12s)
- TJ@1e-12: ~34e-12s (theoretical value: 20e-12 + 2Ã—7.03Ã—10e-12 â‰ˆ 34e-12)

#### 4.3.3 Sampling Strategy Comparison Test (SAMPLING_STRATEGY)

**Scenario Description**:
Evaluate the performance of three sampling strategies (peak/zero-cross/phase-lock) under different signal quality conditions to determine the optimal default strategy.

**Input Data Characteristics**:
- Three datasets corresponding to different SNRs:
  - High SNR: SNR = 30dB, RJ_sigma = 2e-12s
  - Medium SNR: SNR = 20dB, RJ_sigma = 8e-12s
  - Low SNR: SNR = 15dB, RJ_sigma = 15e-12s
- Data Rate: 25 Gbps (UI = 4e-11s)
- Data Length: 100,000 UI

**Parameter Configuration**:
```yaml
test_matrix:
  - sampling: peak
    snr: [30, 20, 15]
  - sampling: zero-cross
    snr: [30, 20, 15]
  - sampling: phase-lock
    snr: [30, 20, 15]

eye:
  ui_bins: 128
  amp_bins: 128
  measure_length: 4e-6
  target_ber: 1e-12
  ui: 4e-11
```

**Verification Points**:
- Eye diagram metrics difference between the three strategies under high SNR < 5%
- Under low SNR, phase-lock strategy eye width is most stable (variation < 10%)
- Peak strategy is sensitive to amplitude noise, eye height estimation deviation > 15% under low SNR
- Zero-cross strategy fails under severe signal distortion (eye width < 0.5 UI)

**Expected Results**:
- phase-lock strategy is most robust under all SNR conditions
- peak strategy has highest accuracy under high SNR, but performance drops sharply under low SNR, suitable for high-quality signals
- zero-cross strategy is suitable for clock recovery scenarios, not for data eye diagram analysis

#### 4.3.4 Large Data Volume Performance Test (PERFORMANCE_STRESS)

**Scenario Description**:
Evaluate EyeAnalyzer's computational efficiency and memory usage when processing large-scale datasets, establishing performance benchmarks.

**Input Data Characteristics**:
- Data Rate: 56 Gbps (UI = 1.7857e-11s)
- Data Scale Gradient:
  - Small: 100,000 UI (total duration 1.7857e-6s)
  - Medium: 1,000,000 UI (total duration 1.7857e-5s)
  - Large: 10,000,000 UI (total duration 1.7857e-4s)
  - Extra Large: 50,000,000 UI (total duration 8.9285e-4s)
- Sampling Rate: 224 GSa/s (4 sampling points per UI)

**Parameter Configuration**:
```yaml
performance:
  data_sizes: [100000, 1000000, 10000000, 50000000]
  ui: 1.7857e-11
  ui_bins: 256
  amp_bins: 256
  measure_length: auto  # Use all data

eye:
  sampling: phase-lock
  target_ber: 1e-12
```

**Verification Points**:
- Analysis time grows linearly with data volume (O(N) complexity)
- Peak memory usage < 2Ã— data size (including intermediate arrays)
- 1M UI data completes analysis within 30 seconds
- 10M UI data completes analysis within 5 minutes
- Memory usage gradient: 100K UI (~50MB) â†’ 1M UI (~200MB) â†’ 10M UI (~1.5GB)

**Performance Benchmarks**:
- Throughput: > 500k UI/second (on Intel i7-12700K)
- Memory Efficiency: < 200 bytes/UI
- Scalability: Supports >100M UI datasets (requires >32GB memory)

#### 4.3.5 Boundary Condition Test (BOUNDARY_CONDITION)

**Scenario Description**:
Verify EyeAnalyzer's robustness and error handling capabilities under extreme or abnormal input to ensure the tool operates safely under various boundary conditions.

**Test Sub-scenarios**:

1. **Short Data Test**:
   - Input: Only 1,000 UI (far below recommended value)
   - Expected: Generate warning, but still produce results with low metric confidence

2. **Single Cycle Data**:
   - Input: Data of exactly 1 UI
   - Expected: Throw exception, prompt insufficient data

3. **Constant Signal**:
   - Input: DC constant value (no transitions)
   - Expected: Eye height=0, Eye width=0, Jitter decomposition fails and prompts

4. **Amplitude Saturation**:
   - Input: Signal amplitude exceeds amp_bins range
   - Expected: Automatically extend amplitude range or truncate with warning

5. **Timestamp Discontinuity**:
   - Input: Timestamps have jumps or duplicates
   - Expected: Detect and warn, attempt to repair or skip abnormal points

**Parameter Configuration**:
```yaml
boundary_tests:
  - name: short_data
    ui_count: 1000
    expect_warning: true
  - name: single_ui
    ui_count: 1
    expect_exception: true
  - name: constant_signal
    signal_type: dc
    expect_eye_height: 0
  - name: amplitude_overflow
    amplitude: 2.0  # Exceeds default range
    expect_warning: true
  - name: timestamp_discontinuity
    gap_ratio: 0.1  # 10% timestamps missing
    expect_warning: true

eye:
  ui: 2.5e-11
  ui_bins: 128
  amp_bins: 128
```

**Verification Points**:
- All boundary scenarios can be handled correctly (no crashes)
- Warning messages are clear and explicit, indicating the cause of the problem
- Abnormal scenarios return meaningful error codes or special values (e.g., NaN)
- Logging is complete for problem diagnosis

#### 4.3.6 Regression Validation Test (REGRESSION_VALIDATION)

**Scenario Description**:
Automatic comparison with reference results to ensure code modifications do not introduce regression issues, maintaining code quality.

**Input Data Characteristics**:
- Use Golden dataset: Pre-generated standard waveform files
- Data Rates: 10Gbps, 25Gbps, 56Gbps three groups
- Include known reference metrics (eye height, eye width, RJ, DJ, etc.)

**Parameter Configuration**:
```yaml
regression:
  golden_data:
    - rate: 10Gbps
      file: golden_10g.dat
      reference_metrics: ref_10g.json
    - rate: 25Gbps
      file: golden_25g.dat
      reference_metrics: ref_25g.json
    - rate: 56Gbps
      file: golden_56g.dat
      reference_metrics: ref_56g.json

  tolerance:
    eye_height: 2%  # Relative error tolerance
    eye_width: 3%
    rj_sigma: 5%
    dj_pp: 4%
    tj_at_ber: 3%

eye:
  ui_bins: 128
  amp_bins: 128
  measure_length: auto
  target_ber: 1e-12
  sampling: phase-lock
```

**Verification Points**:
- All metric deviations from reference values are within tolerance range
- Generate HTML format regression report, including metric comparison tables and trend charts
- When differences exceed threshold, mark as failed and highlight abnormal metrics
- Support historical result comparison, showing performance change trends

**Regression Report Content**:
- Test execution summary (pass/fail counts)
- Metric comparison table (measured value, reference value, deviation, status)
- Deviation trend chart (historical data visualization)
- Detailed analysis of failed items (difference cause diagnosis)

### 4.4 Test Framework Topology

The component connection relationships of EyeAnalyzer's test framework are as follows:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Test Driver (pytest)                              â”‚
â”‚  - Parse test configuration (YAML)                                   â”‚
â”‚  - Schedule test scenarios                                           â”‚
â”‚  - Collect test results                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                â”‚              â”‚              â”‚
        â–¼                 â–¼                â–¼              â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Waveform      â”‚  â”‚ EyeAnalyzer  â”‚  â”‚ Reference  â”‚  â”‚ Result   â”‚  â”‚ Report   â”‚
â”‚ Generator     â”‚  â”‚ Instance     â”‚  â”‚ Calculator â”‚  â”‚ Validatorâ”‚  â”‚ Generatorâ”‚
â”‚               â”‚  â”‚              â”‚  â”‚            â”‚  â”‚          â”‚          â”‚
â”‚ - PRBS Gen    â”‚  â”‚ - Eye Build  â”‚  â”‚ - Theory EHâ”‚  â”‚ - Metric â”‚  â”‚ - HTML   â”‚
â”‚ - Jitter Inj  â”‚  â”‚ - Jitter Dec â”‚  â”‚ - Theory EWâ”‚  â”‚ - Tol Chkâ”‚  â”‚ - CSV    â”‚
â”‚ - Noise Add   â”‚  â”‚ - Metric Ext â”‚  â”‚ - Theory RJâ”‚  â”‚ - Regressâ”‚  â”‚ - JSON   â”‚
â”‚ - Channel Sim â”‚  â”‚ - Visualize  â”‚  â”‚ - Theory DJâ”‚  â”‚          â”‚  â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚                  â”‚                â”‚              â”‚               â”‚
        â”‚                  â”‚                â”‚              â”‚               â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          Data Bus               â”‚
        â”‚  - Waveform Data (numpy array)  â”‚
        â”‚  - Config Parameters (dict)     â”‚
        â”‚  - Reference Metrics (dict)     â”‚
        â”‚  - Measured Results (dict)      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Component Interaction Flow**:

1. **Test Driver** reads YAML configuration file, instantiates waveform generator and EyeAnalyzer
2. **Waveform Generator** generates simulated waveform data according to scenario configuration (or loads Golden data)
3. **EyeAnalyzer Instance** receives waveform and parameters, executes analysis and generates metrics and images
4. **Reference Calculator** calculates theoretical reference values based on input parameters (used for boundary scenarios)
5. **Result Validator** compares measured metrics with reference values/tolerances, determines test pass/fail
6. **Report Generator** summarizes all test results, generates comprehensive reports in HTML/CSV/JSON formats

**Data Flow Description**:
- Waveform data is passed between components as numpy arrays to avoid frequent I/O operations
- Configuration parameters are encapsulated as dictionary objects, supporting nested structures and type checking
- Analysis results use standardized Schema for easy serialization and cross-component transmission

### 4.5 Auxiliary Module Descriptions

#### WaveformGenerator - Waveform Generator

Function: Generate high-fidelity test waveforms, supporting various signal characteristics and impairment models.

**Core Functions**:
- **PRBS Sequence Generation**: Supports PRBS7/9/15/23/31, implemented based on LFSR
- **Jitter Injection**:
  - Random Jitter (RJ): Gaussian distribution, configurable standard deviation
  - Deterministic Jitter (DJ): Sinusoidal modulation, configurable frequency and amplitude
  - Periodic Jitter (PJ): Supports multi-tone PJ injection
- **Noise Addition**: Gaussian white noise, configurable SNR or noise power
- **Channel Simulation**: S-parameter convolution or simple RC low-pass model
- **Nonlinear Distortion**: Soft saturation, amplitude compression and other effects

**Configuration Interface**:
```python
config = {
    'data_rate': 10e9,
    'ui_count': 100000,
    'prbs_type': 'PRBS31',
    'jitter': {
        'rj_sigma': 5e-12,
        'dj_pp': 10e-12,
        'pj_freq': [5e6, 10e6],
        'pj_pp': [2e-12, 1e-12]
    },
    'noise': {
        'snr': 25,  # dB
        'seed': 12345
    },
    'channel': {
        'type': 'rc',
        'bandwidth': 20e9
    }
}
```

**Output Format**: numpy array, shape (N, 2), columns: time(s), value(V)

#### ReferenceCalculator - Reference Metric Calculator

Function: Calculate theoretical reference metrics based on input parameters for verifying EyeAnalyzer result accuracy.

**Calculation Capabilities**:
- **Theoretical Eye Height**: Calculate expected eye height based on signal swing and noise level
- **Theoretical Eye Width**: Calculate expected eye width based on jitter components
- **RJ Theoretical Value**: Directly return injected RJ_sigma
- **DJ Theoretical Value**: Comprehensive data-dependent jitter and periodic jitter
- **TJ Theoretical Value**: Calculate TJ@BER based on dual-Dirac model

**Mathematical Models**:
```
Theoretical Eye Height = V_swing - 3Ã—Ïƒ_noise (considering noise compression effects)
Theoretical Eye Width = UI - DJ_pp - 2Ã—Q(BER)Ã—RJ_sigma
TJ_Theoretical = DJ_Injected + 2Ã—Q(BER)Ã—RJ_Injected
```

**Application Scenarios**: Mainly used in JITTER_DECOMPOSITION and BOUNDARY_CONDITION scenarios, providing objective reference benchmarks.

#### ResultValidator - Result Validator

Function: Automatically verify the accuracy and consistency of EyeAnalyzer output results.

**Validation Rules**:
- **Numerical Range Check**: Whether metrics are within physically reasonable ranges (e.g., eye height>0, eye width>0)
- **Tolerance Comparison**: Whether relative deviation between measured and reference values is within tolerance
- **Consistency Check**: Whether mathematical relationships between related metrics hold (e.g., TJ â‰ˆ DJ + 14Ã—RJ)
- **Regression Detection**: Compare with historical benchmarks to detect performance degradation

**Output Format**:
```python
validation_result = {
    'test_name': 'basic_eye_analysis',
    'passed': True,
    'checks': [
        {'item': 'eye_height', 'value': 0.75, 'reference': 0.78, 
         'deviation': '-3.8%', 'tolerance': '5%', 'status': 'PASS'},
        {'item': 'rj_sigma', 'value': 5.2e-12, 'reference': 5.0e-12,
         'deviation': '+4.0%', 'tolerance': '10%', 'status': 'PASS'}
    ],
    'summary': '2/2 checks passed'
}
```

#### PerformanceProfiler - Performance Analysis Tool

Function: Monitor EyeAnalyzer's execution performance and resource usage.

**Monitoring Metrics**:
- **Execution Time**: Time consumption of each stage (data loading, eye diagram construction, jitter decomposition)
- **Memory Usage**: Peak memory and memory growth curve
- **CPU Utilization**: Multi-core parallel efficiency analysis
- **I/O Throughput**: Data read/write speed

**Analysis Methods**:
- Use `cProfile` for function-level performance profiling
- Use `memory_profiler` to monitor memory usage
- Generate Flame Graph to identify performance bottlenecks
- Output performance benchmark reports, support historical trend comparison

**Application Scenarios**: Core tool for PERFORMANCE_STRESS testing, helping identify optimization opportunities.

#### ReportGenerator - Report Generator

Function: Summarize test results, generate multi-format comprehensive reports.

**Supported Formats**:
- **HTML Report**: Interactive web pages, containing tables, charts and detailed information
- **CSV Export**: Plain text tables for easy data processing and analysis
- **JSON Structured Data**: Machine-readable format, supports CI/CD integration
- **JUnit XML**: Test result format compatible with Jenkins and other CI tools

**Report Content**:
- Test execution summary (pass/fail/skip counts)
- Metric comparison table (measured value, reference value, deviation, status)
- Visualization charts (eye diagram, PSD, PDF, performance trends)
- Detailed analysis and diagnosis suggestions for failed items
- Performance benchmarks and historical trends

**Configuration Options**:
```python
report_config = {
    'output_dir': 'test_reports',
    'include_charts': True,
    'chart_format': 'svg',  # or 'png'
    'compare_with_history': True,
    'history_depth': 10  # Compare with last 10 results
}
```

## 5. Simulation Result Analysis

### 5.1 Statistical Metrics Description

Core metrics generated by EyeAnalyzer can be divided into three categories: eye diagram geometric parameters, jitter decomposition parameters, and signal quality parameters:

| Metric Category | Metric Name | Calculation Method | Physical Meaning | Typical Value Range |
|-----------------|-------------|--------------------|------------------|---------------------|
| **Eye Diagram Geometric Parameters** | Eye Height | V_top(Ï†_opt) - V_bottom(Ï†_opt) | Vertical opening at optimal sampling point, reflects noise margin | 0.5~1.0 V (depends on swing) |
| | Eye Width | Ï†_right(V_th) - Ï†_left(V_th) | Horizontal opening at optimal threshold, reflects timing margin | 0.7~1.0 UI |
| | Opening Area | âˆ«âˆ«_EyeOpening H(Ï†,V) dÏ†dV | Integral of eye diagram opening region, comprehensive quality metric | 0.3~0.8 VÂ·UI |
| | Linearity Error | RMS(V_actual - V_linear_fit) | Linear fitting residual of eye diagram opening region | < 5% (normalized) |
| **Jitter Decomposition Parameters** | Random Jitter (RJ) | Gaussian distribution standard deviation Ïƒ_RJ | Time uncertainty caused by random noise | 1e-12 ~ 1e-11 s |
| | Deterministic Jitter (DJ) | Bimodal distribution spacing Î¼_1 - Î¼_0 | Predictable systematic timing deviation | 5e-12 ~ 5e-11 s |
| | Total Jitter (TJ@BER) | DJ + 2Ã—Q(BER)Ã—RJ | Total timing budget at target bit error rate | DJ + 14Ã—RJ (BER=1e-12) |
| **Signal Quality Parameters** | Signal Mean | Arithmetic mean of all sampling points | Signal DC component | 0 V (differential signal) |
| | RMS Value | sqrt(Î£xÂ²/N) | Signal effective value/power | Swing/âˆš2 |
| | Peak-to-Peak | max(V) - min(V) | Signal dynamic range | 0.8~1.2 V |
| | PSD Peak | max(Pxx(f)) | Power spectral density peak | -40 ~ -20 dBm/Hz |
| | PDF Entropy | -âˆ«p(x)log(p(x))dx | Signal uncertainty measure | 1.5~3.0 bits |

**Inter-metric Relationship Verification**:
- TJ@BER â‰ˆ DJ + 14Ã—RJ (at BER=1e-12, Qâ‰ˆ7.03)
- Eye Width â‰ˆ UI - TJ@BER (in ideal case)
- Eye Height â‰ˆ V_swing - 6Ã—Ïƒ_noise (6Ïƒ rule)

### 5.2 Typical Test Result Interpretation

#### BASIC_EYE_ANALYSIS - Basic Eye Diagram Analysis Results

**Test Configuration**: 10Gbps PRBS-31 signal, 800mV swing, 5mV noise, measure_length=2.5Î¼s

**Expected Result Range**:
- Eye Height: 0.72~0.80 V (input swing 800mV - noise compression)
- Eye Width: 0.92~0.98 UI (ideal 1UI - jitter loss)
- Opening Area: 0.45~0.65 VÂ·UI (eye height Ã— eye width Ã— fill factor)
- RJ_sigma: 4.5~5.5e-12 s (consistent with injected 5e-12s)
- DJ_pp: 0.8~1.2e-11 s (PRBS-31 data-dependent jitter)
- TJ@1e-12: 2.8~3.5e-11 s (DJ + 14Ã—RJ)

**Result Analysis Methods**:
1. **Eye Diagram Visual Inspection**: Eye diagram should show clear "eye" shape, concentrated crossing region, smooth upper and lower boundaries
2. **Metric Rationality Verification**: Eye height + noise < input swing, Eye width + TJ â‰ˆ 1UI
3. **Statistical Convergence**: measure_length increased 10Ã—, metric variation < 3%
4. **Comparison with Reference Values**: Deviation from theoretical calculated values < 10%

**Anomaly Diagnosis**:
- Low eye height: Check noise level, channel attenuation, equalizer configuration
- Small eye width: Check jitter injection, CDR locking, sampling phase
- Small opening area: Comprehensive SNR insufficient, need to optimize link parameters

#### JITTER_DECOMPOSITION - Jitter Decomposition Accuracy Verification Results

**Test Configuration**: PRBS-15, injected RJ=10e-12s, DJ=20e-12s, PJ=5e-12s@5MHz

**Expected Decomposition Accuracy**:
- RJ extraction error: < Â±15% (8.5~11.5e-12s)
- DJ extraction error: < Â±10% (18~22e-12s)
- TJ calculation accuracy: < Â±8% (theoretical value 34e-12s)
- PJ identification: Spectral analysis should show peak at 5MHz

**Result Analysis Methods**:
1. **Eye Diagram Crossing Region Zoom**: Crossing points should show obvious bimodal distribution
2. **PDF Fitting Quality**: Dual-Dirac model goodness of fit RÂ²>0.95
3. **PSD Spectrum Verification**: Periodic jitter should show spectral lines at corresponding frequencies
4. **Multi-group Data Consistency**: Under same injection conditions, 5 measurement standard deviations < 5%

**Error Source Analysis**:
- RJ overestimation: Non-Gaussian noise, quantization error, insufficient samples
- DJ underestimation: Insufficient bimodal separation, RJ noise masking
- TJ deviation: Q function approximation, BER extrapolation error

#### SAMPLING_STRATEGY - Sampling Strategy Comparison Results

**Test Configuration**: 25Gbps signal, three SNR conditions (30dB/20dB/15dB)

**Performance Comparison Matrix**:

| Sampling Strategy | High SNR (30dB) | Medium SNR (20dB) | Low SNR (15dB) | Robustness Score |
|-------------------|-----------------|-------------------|----------------|------------------|
| **phase-lock** | Eye Height: 0.78V (Â±2%) | Eye Height: 0.75V (Â±3%) | Eye Height: 0.70V (Â±5%) | â˜…â˜…â˜…â˜…â˜… |
| | Eye Width: 0.96UI (Â±1%) | Eye Width: 0.93UI (Â±2%) | Eye Width: 0.88UI (Â±4%) | |
| **peak** | Eye Height: 0.79V (Â±1%) | Eye Height: 0.73V (Â±5%) | Eye Height: 0.61V (Â±12%) | â˜…â˜…â˜…â˜†â˜† |
| | Eye Width: 0.96UI (Â±1%) | Eye Width: 0.92UI (Â±3%) | Eye Width: 0.82UI (Â±8%) | |
| **zero-cross** | Eye Height: 0.77V (Â±3%) | Eye Height: 0.68V (Â±8%) | Eye Height: 0.45V (Â±20%) | â˜…â˜…â˜†â˜†â˜† |
| | Eye Width: 0.95UI (Â±2%) | Eye Width: 0.89UI (Â±5%) | Eye Width: 0.71UI (Â±12%) | |

**Interpretation Conclusion**:
- **phase-lock**: Most stable under all conditions, variation rate < 5%, recommended as default strategy
- **peak**: Highest accuracy at high SNR, but performance drops sharply at low SNR, suitable for high-quality signals
- **zero-cross**: Most sensitive to noise, only suitable for clock recovery verification scenarios

#### PERFORMANCE_STRESS - Performance Benchmark Test Results

**Test Configuration**: 56Gbps signal, data scale from 100K UI to 50M UI

**Performance Metric Requirements**:

| Data Scale | Analysis Time | Peak Memory | Throughput | Memory Efficiency |
|------------|---------------|-------------|------------|-------------------|
| 100K UI | < 3s | < 100MB | > 500k UI/s | < 200 bytes/UI |
| 1M UI | < 30s | < 500MB | > 500k UI/s | < 200 bytes/UI |
| 10M UI | < 5min | < 2GB | > 500k UI/s | < 200 bytes/UI |
| 50M UI | < 30min | < 10GB | > 500k UI/s | < 200 bytes/UI |

**Performance Bottleneck Analysis**:
1. **Data Loading Stage**: I/O bandwidth limitation, recommend SSD storage
2. **Eye Diagram Construction Stage**: CPU-intensive, supports multi-core parallel acceleration
3. **Jitter Decomposition Stage**: Numerical computation, can use GPU acceleration (optional)
4. **Visualization Stage**: Image rendering, can downsample or generate asynchronously

**Optimization Suggestions**:
- Use `measure_length` to truncate key segments for large datasets
- Lower `ui_bins`/`amp_bins` resolution to trade off accuracy for speed
- Turn off `save_csv_data` to reduce I/O overhead
- Enable `hist2d_normalize=False` to save normalization time

#### BOUNDARY_CONDITION - Boundary Condition Handling Results

**Key Boundary Scenario Verification**:

1. **Short Data Test** (1,000 UI)
   - Result: Generate warning "Insufficient data for stable statistics"
   - Eye Diagram: Blurry outline, metric confidence < 70%
   - Recommendation: measure_length should be > 10,000 UI

2. **Single Cycle Data** (1 UI)
   - Result: Throw exception "Data length < 100 UI, analysis aborted"
   - Protection Mechanism: Prevent division by zero errors and memory overflow

3. **Constant Signal** (DC)
   - Result: Eye height=0, Eye width=0, RJ/DJ=NaN
   - Error Code: `EYE_OPENING_ZERO`
   - Diagnostic Prompt: Check signal source or link connection

4. **Amplitude Overflow** (>2V)
   - Result: Automatically extend amp_bins range, warning "Amplitude range extended"
   - Protection Mechanism: Dynamically adjust histogram boundaries

5. **Timestamp Discontinuity**
   - Result: Warning "Timestamp gap detected at t=xxxs"
   - Handling Strategy: Linear interpolation or skip abnormal segments

**Robustness Assessment**: EyeAnalyzer does not crash under all boundary scenarios, error handling mechanism is complete, meets production-grade tool requirements.

#### REGRESSION_VALIDATION - Regression Test Results

**Regression Test Standards**:

| Metric | Tolerance | Test 10Gbps | Test 25Gbps | Test 56Gbps | Status |
|--------|-----------|-------------|-------------|-------------|--------|
| Eye Height | Â±2% | +1.2% | -0.8% | +1.5% | PASS |
| Eye Width | Â±3% | +0.5% | -1.2% | +2.1% | PASS |
| RJ | Â±5% | +2.3% | +3.1% | -1.8% | PASS |
| DJ | Â±4% | -0.9% | +2.7% | +1.3% | PASS |
| TJ | Â±3% | +1.1% | +1.8% | +0.7% | PASS |

**Regression Trend Analysis**:
- **Performance Degradation Detection**: If a commit causes metric deviation > tolerance, mark as regression failure
- **Performance Improvement Identification**: If metrics consistently outperform reference values, update Golden dataset
- **Historical Trend Chart**: Plot metric change curves for the last 20 commits to identify long-term trends

**CI/CD Integration**:
- Regression testing as a required check item for GitHub Actions
- Block PR merge on failure, require developer fix or update reference values
- Generate JUnit XML report for seamless integration with CI systems

### 5.3 Waveform Data File Format

#### 5.3.1 Input File Format (SystemC-AMS Tabular)

**File Extension**: `.dat` (text format) or `.tdf` (binary format, better performance)

**Text Format Example** (`results.dat`):
```
# SystemC-AMS Tabular Trace File
# Time(s)    voltage(V)
0.000000e+00    0.000000e+00
1.000000e-11    5.234567e-03
2.000000e-11    1.234567e-01
3.000000e-11    2.345678e-01
... (N rows)
2.500000e-06    3.456789e-01
```

**Format Specifications**:
- **Comment Lines**: Start with `#`, can contain metadata
- **Data Columns**: At least 2 columns, column 1 is time(s), column 2 is signal value(V)
- **Separators**: Space or tab, supports automatic recognition
- **Scientific Notation**: Conforms to IEEE 754 standard
- **Time Monotonicity**: Must be strictly increasing, step size can be unequal

**Multi-signal Support** (Extended Format):
```
# Time(s)    v_in(V)    v_out(V)    v_clk(V)
0.000000e+00    0.0    0.0    0.6
1.000000e-11    0.1    0.15   0.6
...
```
EyeAnalyzer reads column 2 by default, can be specified via `signal_column` parameter.

#### 5.3.2 Output File Format

**1. Eye Diagram Metrics JSON (`eye_metrics.json`)**

```json
{
  "metadata": {
    "version": "1.0",
    "timestamp": "2026-01-21T10:30:00Z",
    "dat_path": "results.dat",
    "ui": 2.5e-11,
    "ui_bins": 128,
    "amp_bins": 128,
    "measure_length": 2.5e-6
  },
  "eye_geometry": {
    "eye_height": 0.756,
    "eye_width": 0.942,
    "eye_area": 0.523,
    "linearity_error": 0.032,
    "optimal_sampling_phase": 0.512,
    "optimal_threshold": 0.003
  },
  "jitter_decomposition": {
    "rj_sigma": 5.2e-12,
    "dj_pp": 1.1e-11,
    "tj_at_ber": 3.28e-11,
    "target_ber": 1e-12,
    "q_factor": 7.034,
    "method": "dual-dirac"
  },
  "signal_quality": {
    "mean": -0.001,
    "rms": 0.387,
    "peak_to_peak": 0.823,
    "psd_peak_freq": 5.2e9,
    "psd_peak_value": -28.5
  },
  "data_provenance": {
    "total_samples": 250000,
    "analyzed_samples": 100000,
    "sampling_rate": 80e9,
    "duration": 2.5e-6
  }
}
```

**2. Eye Diagram Image File (`eye_diagram.png/svg/pdf`)**

**PNG Format** (Default):
- Resolution: Configurable DPI (default 300)
- Color Map: 'hot' (density heatmap)
- Includes: Eye diagram outline, metric annotations, color bar
- File Size: ~200KB (128Ã—128 bins)

**SVG Format** (Recommended for Reports):
- Vector graphics, infinite zoom
- Editable text annotations
- File Size: ~500KB
- Supports embedding in web pages

**PDF Format** (For Papers):
- High-quality vector output
- Supports multiple pages
- File Size: ~300KB

**3. Auxiliary Data CSV (`eye_analysis_data/`)**

**2D Density Matrix** (`hist2d.csv`):
```csv
phase_bin,amplitude_bin,density
0,0,0.000123
0,1,0.000234
...
127,127,0.000045
```

**PSD Data** (`psd.csv`):
```csv
frequency_hz,psd_v2_per_hz
0.000000e+00,1.234567e-08
1.000000e+06,8.765432e-09
...
4.000000e+10,2.345678e-11
```

**PDF Data** (`pdf.csv`):
```csv
amplitude_v,probability_density
-0.500,0.000012
-0.495,0.000023
...
0.500,0.000015
```

**Jitter Distribution** (`jitter_distribution.csv`):
```csv
time_offset_s,probability
-5.000e-11,0.0012
-4.995e-11,0.0015
...
5.000e-11,0.0013
```

#### 5.3.3 Data Format Conversion Tools

**dat â†’ numpy array**:
```python
import numpy as np
t, v = np.loadtxt('results.dat', skiprows=2, unpack=True)
```

**JSON â†’ pandas DataFrame**:
```python
import pandas as pd
import json
with open('eye_metrics.json', 'r') as f:
    metrics = json.load(f)
df = pd.json_normalize(metrics)
```

**CSV â†’ MATLAB**:
```matlab
% Read eye diagram density matrix
M = csvread('hist2d.csv');
phase = reshape(M(:,1), 128, 128);
amplitude = reshape(M(:,2), 128, 128);
density = reshape(M(:,3), 128, 128);

% Plot eye diagram
imagesc(phase(1,:), amplitude(:,1), density);
colorbar;
xlabel('UI Phase');
ylabel('Amplitude (V)');
title('Eye Diagram');
```

**Batch Conversion Script** (`scripts/convert_eye_data.py`):
```bash
python scripts/convert_eye_data.py --input results.dat --format numpy,hdf5
# Output results.npy and results.h5
```

## 6. Running Guide

### 6.1 Environment Configuration

As a Python analysis component, EyeAnalyzer requires configuring the Python environment and related dependency libraries.

#### 6.1.1 Python Version Requirements

- **Python**: 3.8 or higher (recommended 3.10+)
- **pip**: Latest version (recommended to run `pip install --upgrade pip`)

#### 6.1.2 Dependency Library Installation

EyeAnalyzer depends on the following core libraries, which can be installed with one click via pip:

```bash
# Basic dependencies (required)
pip install numpy scipy matplotlib

# Optional dependencies (recommended)
pip install pandas  # For JSON/CSV data processing
pip install pytest  # For running test platform
pip install memory_profiler  # For performance profiling
```

**Dependency Version Recommendations**:
- numpy â‰¥ 1.20.0
- scipy â‰¥ 1.7.0
- matplotlib â‰¥ 3.5.0
- pandas â‰¥ 1.3.0 (optional)

#### 6.1.3 Virtual Environment Configuration (Recommended)

To avoid dependency conflicts, it is recommended to use a virtual environment:

```bash
# Create virtual environment
python -m venv eye_analyzer_env

# Activate virtual environment
source eye_analyzer_env/bin/activate  # Linux/macOS
# eye_analyzer_env\Scripts\activate  # Windows

# Install dependencies
pip install numpy scipy matplotlib pandas pytest
```

#### 6.1.4 Environment Variable Configuration

EyeAnalyzer supports default parameter configuration through environment variables:

```bash
# Set default output directory
export EYE_ANALYZER_OUTPUT_DIR=./eye_analysis_results

# Set default image DPI
export EYE_ANALYZER_DPI=300

# Set default image format
export EYE_ANALYZER_IMAGE_FORMAT=png

# Add to .bashrc or .zshrc for persistent configuration
echo 'export EYE_ANALYZER_OUTPUT_DIR=./eye_analysis_results' >> ~/.bashrc
source ~/.bashrc
```

### 6.2 Build and Run

EyeAnalyzer provides three usage methods: API calls, command line tools, and pytest test framework.

#### 6.2.1 API Call Method (Recommended)

Call EyeAnalyzer functions directly in Python scripts:

```python
from eye_analyzer import analyze_eye

# Basic call
metrics = analyze_eye(
    dat_path='results.dat',
    ui=2.5e-11,  # 10Gbps
    ui_bins=128,
    amp_bins=128,
    measure_length=2.5e-6,
    target_ber=1e-12
)

# Print key metrics
print(f"Eye Height: {metrics['eye_geometry']['eye_height']:.3f} V")
print(f"Eye Width: {metrics['eye_geometry']['eye_width']:.3f} UI")
print(f"RJ: {metrics['jitter_decomposition']['rj_sigma']:.2e} s")
```

**API Parameter Description**:
- `dat_path`: Input waveform file path (mutually exclusive with `waveform_array`)
- `waveform_array`: In-memory waveform array (NumPy ndarray)
- `ui`: Unit interval (seconds), required parameter
- `ui_bins`: Eye diagram horizontal resolution (default 128)
- `amp_bins`: Eye diagram vertical resolution (default 128)
- `measure_length`: Statistical duration (seconds, default 1e-4)
- `target_ber`: Target bit error rate (default 1e-12)
- `sampling`: Sampling strategy ('phase-lock', 'peak', 'zero-cross')
- `output_image_format`: Output image format ('png', 'svg', 'pdf')
- `save_csv_data`: Whether to save auxiliary CSV data (default False)

#### 6.2.2 Command Line Tool Method

EyeAnalyzer provides a command line interface (requires implementing `eye_analyzer/cli.py`):

```bash
# Basic analysis
python -m eye_analyzer --dat results.dat --ui 2.5e-11

# Advanced configuration
python -m eye_analyzer \
    --dat results.dat \
    --ui 2.5e-11 \
    --ui-bins 256 \
    --amp-bins 256 \
    --measure-length 5e-6 \
    --target-ber 1e-12 \
    --sampling phase-lock \
    --output-image-format svg \
    --save-csv-data

# View help
python -m eye_analyzer --help
```

**Command Line Parameter Mapping**:
| Command Line Parameter | API Parameter | Description |
|------------------------|---------------|-------------|
| `--dat` | `dat_path` | Input waveform file |
| `--ui` | `ui` | Unit interval (seconds) |
| `--ui-bins` | `ui_bins` | Horizontal resolution |
| `--amp-bins` | `amp_bins` | Vertical resolution |
| `--measure-length` | `measure_length` | Statistical duration |
| `--target-ber` | `target_ber` | Target bit error rate |
| `--sampling` | `sampling` | Sampling strategy |
| `--output-image-format` | `output_image_format` | Image format |
| `--save-csv-data` | `save_csv_data` | Save CSV data |

#### 6.2.3 pytest Test Framework Method

Run EyeAnalyzer test platform (requires implementing `tests/test_eye_analyzer.py`):

```bash
# Install pytest
pip install pytest pytest-html

# Run all tests
pytest tests/test_eye_analyzer.py -v

# Run specific test scenario
pytest tests/test_eye_analyzer.py::test_basic_eye_analysis -v
pytest tests/test_eye_analyzer.py::test_jitter_decomposition -v
pytest tests/test_eye_analyzer.py::test_sampling_strategy -v

# Generate HTML test report
pytest tests/test_eye_analyzer.py -v --html=report.html --self-contained-html

# Run performance test (large data volume)
pytest tests/test_eye_analyzer.py::test_performance_stress -v -s

# Run regression test (compare with reference results)
pytest tests/test_eye_analyzer.py::test_regression_validation -v
```

**Test Scenario Parameters**:
The test platform supports 6 core scenarios, selected via pytest command line:
- `test_basic_eye_analysis`: Basic eye diagram analysis
- `test_jitter_decomposition`: Jitter decomposition accuracy verification
- `test_sampling_strategy`: Sampling strategy comparison
- `test_performance_stress`: Large data volume performance test
- `test_boundary_condition`: Boundary condition handling
- `test_regression_validation`: Regression test

#### 6.2.4 Typical Running Examples

**Example 1: Quick Analysis** (default parameters, suitable for preliminary evaluation)
```python
from eye_analyzer import analyze_eye

# Quick analysis using default parameters
metrics = analyze_eye('results.dat', ui=2.5e-11)

# Results automatically saved to eye_metrics.json and eye_diagram.png
print(f"Analysis complete! Eye Height: {metrics['eye_geometry']['eye_height']*1000:.1f} mV")
```

**Example 2: High-precision Analysis** (high resolution, suitable for detailed study)
```python
from eye_analyzer import analyze_eye

# High-precision configuration
metrics = analyze_eye(
    dat_path='results.dat',
    ui=2.5e-11,
    ui_bins=256,
    amp_bins=256,
    measure_length=5e-6,
    target_ber=1e-15,
    sampling='phase-lock',
    output_image_format='svg',
    output_image_dpi=600,
    save_csv_data=True,
    csv_data_path='detailed_analysis'
)

# Generate detailed report
print(f"Eye Height: {metrics['eye_geometry']['eye_height']*1000:.2f} mV")
print(f"Eye Width: {metrics['eye_geometry']['eye_width']*1000:.2f} mUI")
print(f"RJ: {metrics['jitter_decomposition']['rj_sigma']*1e12:.2f} ps")
print(f"DJ: {metrics['jitter_decomposition']['dj_pp']*1e12:.2f} ps")
```

**Example 3: Batch Processing** (multiple data files)
```python
from eye_analyzer import analyze_eye
import glob

# Batch process all .dat files
for dat_file in glob.glob('*.dat'):
    print(f"Analyzing {dat_file}...")
    metrics = analyze_eye(dat_file, ui=2.5e-11)
    
    # Save results with filename
    output_name = dat_file.replace('.dat', '_metrics')
    # Results automatically saved to {output_name}.json
```

### 6.3 Result Viewing

EyeAnalyzer generates result files in multiple formats, which can be viewed using different tools.

#### 6.3.1 JSON Metrics File Viewing

Use Python to read and view eye diagram metrics:

```python
import json

# Read JSON file
with open('eye_metrics.json', 'r') as f:
    metrics = json.load(f)

# View eye diagram geometric parameters
print("=== Eye Diagram Geometric Parameters ===")
print(f"Eye Height: {metrics['eye_geometry']['eye_height']*1000:.2f} mV")
print(f"Eye Width: {metrics['eye_geometry']['eye_width']*1000:.2f} mUI")
print(f"Opening Area: {metrics['eye_geometry']['eye_area']*1e6:.2f} Î¼VÂ·UI")
print(f"Linearity Error: {metrics['eye_geometry']['linearity_error']*100:.2f}%")

# View jitter decomposition parameters
print("\n=== Jitter Decomposition Parameters ===")
print(f"Random Jitter RJ: {metrics['jitter_decomposition']['rj_sigma']*1e12:.2f} ps")
print(f"Deterministic Jitter DJ: {metrics['jitter_decomposition']['dj_pp']*1e12:.2f} ps")
print(f"Total Jitter TJ@BER: {metrics['jitter_decomposition']['tj_at_ber']*1e12:.2f} ps")
print(f"Target Bit Error Rate: {metrics['jitter_decomposition']['target_ber']:.0e}")

# View signal quality parameters
print("\n=== Signal Quality Parameters ===")
print(f"Mean: {metrics['signal_quality']['mean']*1000:.2f} mV")
print(f"RMS: {metrics['signal_quality']['rms']*1000:.2f} mV")
print(f"Peak-to-Peak: {metrics['signal_quality']['peak_to_peak']*1000:.2f} mV")
```

Use command line tools for quick viewing:
```bash
# Use jq tool (requires installing jq)
jq '.eye_geometry' eye_metrics.json
jq '.jitter_decomposition' eye_metrics.json

# Use Python command line
python -c "import json; import sys; d=json.load(sys.stdin)" < eye_metrics.json
```

#### 6.3.2 Eye Diagram Image Viewing

Eye diagram images generated by EyeAnalyzer can be viewed using various tools:

**Use system default image viewer**:
```bash
# Linux
xdg-open eye_diagram.png

# macOS
open eye_diagram.png

# Windows
start eye_diagram.png
```

**Use Python interactive viewing**:
```python
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Read and display image
img = mpimg.imread('eye_diagram.png')
plt.figure(figsize=(10, 8))
plt.imshow(img)
plt.axis('off')
plt.title('Eye Diagram')
plt.show()
```

**Use Surfer (recommended for macOS)**:
```bash
# Surfer provides excellent waveform and image viewing experience
surfer eye_diagram.png &
```

#### 6.3.3 CSV Auxiliary Data Viewing

For saved CSV auxiliary data, pandas can be used for analysis:

```python
import pandas as pd
import matplotlib.pyplot as plt

# Read 2D density matrix
df_hist = pd.read_csv('eye_analysis_data/hist2d.csv')

# Read PSD data
df_psd = pd.read_csv('eye_analysis_data/psd.csv')

# Read PDF data
df_pdf = pd.read_csv('eye_analysis_data/pdf.csv')

# Plot PSD
plt.figure(figsize=(10, 6))
plt.semilogx(df_psd['frequency_hz'], 10*np.log10(df_psd['psd_v2_per_hz']))
plt.xlabel('Frequency (Hz)')
plt.ylabel('PSD (dBm/Hz)')
plt.title('Power Spectral Density')
plt.grid(True)
plt.show()

# Plot PDF
plt.figure(figsize=(10, 6))
plt.plot(df_pdf['amplitude_v'], df_pdf['probability_density'])
plt.xlabel('Amplitude (V)')
plt.ylabel('Probability Density')
plt.title('Probability Density Function')
plt.grid(True)
plt.show()
```

#### 6.3.4 Interactive Visualization Tools

**Use Jupyter Notebook/Lab**:
```python
import json
import matplotlib.pyplot as plt
from IPython.display import Image, display

# Load JSON metrics
with open('eye_metrics.json', 'r') as f:
    metrics = json.load(f)

# Display eye diagram image
display(Image(filename='eye_diagram.png'))

# Plot metrics summary
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Eye diagram geometric parameters
axes[0, 0].bar(['Eye Height', 'Eye Width', 'Eye Area'], 
               [metrics['eye_geometry']['eye_height']*1000,
                metrics['eye_geometry']['eye_width']*1000,
                metrics['eye_geometry']['eye_area']*1e6])
axes[0, 0].set_title('Eye Geometry')
axes[0, 0].set_ylabel('Value')

# Jitter decomposition parameters
axes[0, 1].bar(['RJ', 'DJ', 'TJ@BER'], 
               [metrics['jitter_decomposition']['rj_sigma']*1e12,
                metrics['jitter_decomposition']['dj_pp']*1e12,
                metrics['jitter_decomposition']['tj_at_ber']*1e12])
axes[0, 1].set_title('Jitter Decomposition')
axes[0, 1].set_ylabel('Jitter (ps)')

# Signal quality parameters
axes[1, 0].bar(['Mean', 'RMS'], 
               [metrics['signal_quality']['mean']*1000,
                metrics['signal_quality']['rms']*1000])
axes[1, 0].set_title('Signal Quality')
axes[1, 0].set_ylabel('Voltage (mV)')

# Metadata
axes[1, 1].text(0.1, 0.5, f"UI: {metrics['metadata']['ui']*1e12:.2f} ps\n"
                             f"UI Bins: {metrics['metadata']['ui_bins']}\n"
                             f"Amp Bins: {metrics['metadata']['amp_bins']}\n"
                             f"Target BER: {metrics['jitter_decomposition']['target_ber']:.0e}",
                fontsize=12, verticalalignment='center')
axes[1, 1].set_title('Metadata')
axes[1, 1].axis('off')

plt.tight_layout()
plt.show()
```

**Use Plotly to create interactive charts**:
```python
import plotly.graph_objects as go
import json

# Read JSON data
with open('eye_metrics.json', 'r') as f:
    metrics = json.load(f)

# Create interactive eye diagram metrics dashboard
fig = go.Figure()

# Add eye diagram geometric parameters
fig.add_trace(go.Bar(
    x=['Eye Height (mV)', 'Eye Width (mUI)', 'Opening Area (Î¼VÂ·UI)'],
    y=[metrics['eye_geometry']['eye_height']*1000,
       metrics['eye_geometry']['eye_width']*1000,
       metrics['eye_geometry']['eye_area']*1e6],
    name='Eye Diagram Geometric Parameters'
))

fig.update_layout(
    title='Eye Analyzer Interactive Results',
    xaxis_title='Parameters',
    yaxis_title='Values',
    showlegend=True
)

fig.show()
```

#### 6.3.5 Automated Report Generation

**Use ReportGenerator to generate comprehensive reports**:
```python
from eye_analyzer.report_generator import ReportGenerator

# Create report generator
report_gen = ReportGenerator(
    output_dir='test_reports',
    include_charts=True,
    chart_format='svg',
    compare_with_history=True,
    history_depth=10
)

# Generate HTML report
report_gen.generate_report(
    metrics_file='eye_metrics.json',
    eye_image='eye_diagram.png',
    csv_data_dir='eye_analysis_data',
    test_name='basic_eye_analysis',
    reference_file='ref_metrics.json'
)

print("Report generated: test_reports/eye_analysis_report.html")
```

**Integrate reports in CI/CD**:
```yaml
# GitHub Actions example
- name: Run Eye Analyzer
  run: |
    python -m eye_analyzer --dat results.dat --ui 2.5e-11
    
- name: Upload Report
  uses: actions/upload-artifact@v3
  with:
    name: eye-analysis-report
    path: |
      eye_metrics.json
      eye_diagram.png
      eye_analysis_data/
```

## 7. Technical Key Points

### 7.1 Why at Least 10,000 UI Data is Needed

Eye diagram analysis is based on statistical methods, requiring sufficient samples to ensure convergence of the Law of Large Numbers. Testing shows:
- < 1,000 UI: Metric fluctuation > 30%, low confidence
- 10,000 UI: Metric fluctuation < 10%, basically usable
- 100,000 UI: Metric fluctuation < 3%, recommended value
- > 1,000,000 UI: Metric fluctuation < 1%, suitable for high-precision analysis

### 7.2 Trade-offs in Selecting ui_bins and amp_bins

- **Too Low Resolution** (< 64 bins): Blurry eye diagram outline, large metric calculation errors
- **Too High Resolution** (> 512 bins): Increased computation time, large memory usage, obvious statistical noise
- **Recommended Values**: 128-256 bins, achieving balance between accuracy and performance
- **Special Scenarios**: For ultra-high-speed links (> 50Gbps), recommend 256 bins or higher

### 7.3 Impact of Phase Estimation Error on Eye Width

Simulations show that phase estimation error Î”Ï† causes eye width measurement deviation:
```
Î”eye_width â‰ˆ -2 Ã— Î”Ï† (when Î”Ï† < 0.1 UI)
```
The phase error of the phase-lock strategy is typically < 0.01 UI, corresponding to eye width deviation < 2%

### 7.4 Sample Size Requirements for Jitter Decomposition

The dual-Dirac model requires sufficient crossing point samples:
- RJ extraction: At least 1,000 crossing points
- DJ extraction: At least 5,000 crossing points
- TJ@BER calculation: At least 10,000 crossing points

For PRBS-31, 10,000 UI produces approximately 5,000 crossing points (density ~0.5)

### 7.5 Memory Optimization Strategies

EyeAnalyzer's memory usage mainly comes from:
- Waveform array: N Ã— 16 bytes (float64)
- 2D histogram: ui_bins Ã— amp_bins Ã— 8 bytes
- Intermediate arrays: Approximately 2-3Ã— waveform array size

Optimization suggestions:
- Use `measure_length` to truncate data, avoiding loading full waveforms
- Appropriately reduce `ui_bins` and `amp_bins` resolution
- Use `np.float32` instead of `np.float64` (precision loss < 1%)

### 7.6 Comparison with Other Eye Diagram Analysis Tools

| Tool | Advantages | Disadvantages | Applicable Scenarios |
|------|------------|---------------|----------------------|
| **EyeAnalyzer** | Integrated jitter decomposition, Python ecosystem, open source | Performance lower than commercial tools | R&D, CI/CD |
| **Keysight ADS** | High accuracy, comprehensive functions | Expensive, closed | Production testing |
| **MATLAB** | Flexible algorithms, strong visualization | High cost, complex deployment | Algorithm research |

### 7.7 Known Limitations

- Does not support PAM-4 and above modulation formats (NRZ only)
- Dual-Dirac model assumes Gaussian distribution, accuracy decreases for strongly non-Gaussian jitter
- Large datasets (> 50M UI) require > 32GB memory
- Does not support real-time eye diagram analysis (post-processing only)

## 8. Reference Information

### 8.1 Related Files

As a Python post-processing component of the SerDes project, EyeAnalyzer-related files are distributed across multiple directories in the project. The following is the complete file list:

| File Category | File Path | Description |
|---------------|-----------|-------------|
| **Core Modules** | `scripts/eye_analyzer.py` | EyeAnalyzer main module implementation |
| | `scripts/analyze_eye.py` | Command line interface script |
| **Test Framework** | `tests/unit/test_eye_analyzer.py` | Unit test suite (6 test scenarios) |
| | `tests/performance/test_eye_performance.py` | Performance benchmark testing |
| **Auxiliary Tools** | `scripts/plot_ctle_waveform.py` | Waveform visualization script (reference) |
| | `scripts/run_ctle_tests.sh` | CTLE test run script (reference) |
| **Configuration Templates** | `config/default.json` | Project default JSON configuration (includes EyeAnalyzer parameters) |
| | `config/default.yaml` | Project default YAML configuration (includes EyeAnalyzer parameters) |
| **Documentation** | `docs/modules/EyeAnalyzer.md` | This technical document |
| | `docs/checklist.md` | Module documentation checklist |
| **Project Build** | `CMakeLists.txt` | CMake build configuration |
| | `Makefile` | Makefile build configuration |
| | `Dockerfile` | Docker container configuration |
| **Dependency Management** | `requirements.txt` | Python dependency package list (if exists) |

> **Note**: EyeAnalyzer is a Python analysis component, different from SystemC-AMS simulation modules, no C++ compilation build required. Mainly depends on Python interpreter and related scientific computing libraries.

### 8.2 Dependencies

EyeAnalyzer depends on the following Python libraries, recommended to install in an isolated virtual environment:

#### 8.2.1 Core Dependencies (Required)

| Library Name | Version Requirement | Purpose |
|--------------|---------------------|---------|
| **Python** | â‰¥ 3.8 (recommended 3.10+) | Runtime environment |
| **numpy** | â‰¥ 1.20.0 | Numerical computation, array operations |
| **scipy** | â‰¥ 1.7.0 | Scientific computing (PSD, PDF, statistics) |
| **matplotlib** | â‰¥ 3.5.0 | Eye diagram plotting and visualization |

#### 8.2.2 Optional Dependencies (Recommended)

| Library Name | Version Requirement | Purpose |
|--------------|---------------------|---------|
| **pandas** | â‰¥ 1.3.0 | JSON/CSV data processing, DataFrame |
| **pytest** | â‰¥ 7.0.0 | Testing framework |
| **memory_profiler** | â‰¥ 0.60.0 | Memory usage analysis |
| **tqdm** | â‰¥ 4.60.0 | Progress bar display (for large data volumes) |
| **PyYAML** | â‰¥ 6.0 | YAML configuration file parsing |

#### 8.2.3 Development Dependencies (Development and CI/CD)

| Library Name | Version Requirement | Purpose |
|--------------|---------------------|---------|
| **pytest-html** | â‰¥ 3.0.0 | Generate HTML test reports |
| **pytest-cov** | â‰¥ 3.0.0 | Code coverage statistics |
| **black** | â‰¥ 22.0.0 | Code formatting |
| **flake8** | â‰¥ 4.0.0 | Code style checking |
| **mypy** | â‰¥ 0.950 | Type checking |

#### 8.2.4 Installation Commands

```bash
# Basic installation (required dependencies)
pip install numpy scipy matplotlib

# Recommended installation (includes optional dependencies)
pip install numpy scipy matplotlib pandas pytest memory_profiler

# Full installation (includes development dependencies)
pip install -r requirements-dev.txt

# Install from requirements.txt
pip install -r requirements.txt
```

### 8.3 Configuration Examples

#### 8.3.1 Basic Configuration (10Gbps NRZ Signal)

```json
{
  "eye_analyzer": {
    "ui": 2.5e-11,
    "ui_bins": 128,
    "amp_bins": 128,
    "measure_length": 2.5e-6,
    "target_ber": 1e-12,
    "sampling": "phase-lock",
    "output_image_format": "png",
    "output_image_dpi": 300,
    "save_csv_data": false
  }
}
```

#### 8.3.2 High-precision Configuration (25Gbps PAM4 Signal)

```json
{
  "eye_analyzer": {
    "ui": 1.6e-11,
    "ui_bins": 256,
    "amp_bins": 256,
    "measure_length": 5e-6,
    "target_ber": 1e-15,
    "sampling": "phase-lock",
    "jitter_extract_method": "dual-dirac",
    "psd_nperseg": 32768,
    "output_image_format": "svg",
    "output_image_dpi": 600,
    "save_csv_data": true,
    "csv_data_path": "detailed_analysis"
  }
}
```

#### 8.3.3 Quick Analysis Configuration (for debugging)

```json
{
  "eye_analyzer": {
    "ui": 2.5e-11,
    "ui_bins": 64,
    "amp_bins": 64,
    "measure_length": 1e-6,
    "target_ber": 1e-9,
    "sampling": "peak",
    "hist2d_normalize": false,
    "output_image_format": "png",
    "output_image_dpi": 150
  }
}
```

#### 8.3.4 YAML Format Configuration Example

```yaml
eye_analyzer:
  ui: 2.5e-11
  ui_bins: 128
  amp_bins: 128
  measure_length: 2.5e-6
  target_ber: 1e-12
  sampling: phase-lock
  jitter_extract_method: dual-dirac
  output_image_format: png
  output_image_dpi: 300
  save_csv_data: false
```

#### 8.3.5 Multi-rate Link Configuration (supports different rates)

```json
{
  "eye_analyzer": {
    "multi_rate": {
      "10Gbps": {
        "ui": 2.5e-11,
        "ui_bins": 128,
        "amp_bins": 128
      },
      "25Gbps": {
        "ui": 1.0e-11,
        "ui_bins": 192,
        "amp_bins": 192
      },
      "56Gbps": {
        "ui": 1.7857e-11,
        "ui_bins": 256,
        "amp_bins": 256
      }
    },
    "common": {
      "measure_length": 2.5e-6,
      "target_ber": 1e-12,
      "sampling": "phase-lock",
      "output_image_format": "png"
    }
  }
}
```

---

**Document Version**: v1.0  
**Last Updated**: 2026-01-23  
**Author**: Yizhe Liu
