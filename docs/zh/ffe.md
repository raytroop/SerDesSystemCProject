# TX FFE 模块技术文档

🌐 **Languages**: [中文](ffe.md) | [English](../en/modules/ffe.md)

**级别**：AMS 子模块（TX）  
**类名**：`TxFfeTdf`  
**当前版本**：v0.1 (2026-01-13)  
**状态**：开发中

---

## 1. 概述

前置均衡器（FFE，Feed-Forward Equalizer）是SerDes发送端的核心信号调理模块，位于WaveGen之后、Mux之前，主要功能是在发送端提前补偿信道引入的码间干扰（ISI），通过对数据进行预失真处理，使信号在经过信道衰减后能够在接收端恢复为更加清晰的眼图，降低接收端均衡器的负担。

### 1.1 设计原理

FFE的核心设计思想是利用有限冲激响应（FIR）滤波器结构，根据信道的频率响应特性，在发送端对信号进行频率选择性的预加重（Pre-emphasis）或去加重（De-emphasis），实现ISI的预补偿。

#### 1.1.1 ISI形成机制与预补偿策略

在高速串行链路中，信道的频率相关损耗会导致高频分量衰减更严重，使得信号边沿变缓，相邻码元之间产生相互干扰（ISI）。ISI可以分解为：

- **前游标（Pre-cursor）ISI**：当前码元受到前一个码元的干扰，表现为信号上升/下降沿提前出现的拖尾效应。
- **后游标（Post-cursor）ISI**：当前码元受到后续码元的干扰，表现为信号跳变后未能完全稳定到目标电平。

FFE通过FIR结构实现预补偿：

- **前置抽头（Pre-tap）**：对应前游标补偿，通过提前注入反向极性的信号分量，抵消信道产生的前游标ISI。
- **主抽头（Main tap）**：对应当前码元的主要能量，通常具有最大的权重系数。
- **后置抽头（Post-tap）**：对应后游标补偿，通过叠加延迟码元的反向分量，预先消除信道的后游标ISI。

#### 1.1.2 FIR滤波器实现

FFE采用离散时间FIR滤波器结构，数学表达式为：

```
y[n] = Σ c[k] × x[n-k]
       k=0 to N-1
```

其中：
- `y[n]`：第n个输出码元
- `x[n-k]`：延迟k个符号间隔（UI）的输入码元
- `c[k]`：第k个抽头的权重系数
- `N`：抽头总数

抽头系数的设置遵循以下原则：

- **归一化约束**：为保证输出信号的平均功率与输入一致，通常要求 `Σ|c[k]| ≈ 1`。
- **主抽头最大原则**：主抽头（通常为c[1]或c[2]）具有最大幅值，确保主要信号能量集中在当前码元。
- **对称性考虑**：对于对称的信道冲激响应，FFE抽头系数也可能呈现对称或准对称分布，但实际应用中通常后置抽头权重大于前置抽头（因为因果系统中后游标ISI更严重）。

#### 1.1.3 预加重与去加重

FFE有两种常见的实现策略，区别在于主抽头的相对位置和功率分配：

- **预加重（Pre-emphasis）**：主抽头位于中间或靠后，前置抽头系数为正，后置抽头系数为负。这种方式会在跳变边沿提前注入能量，增强高频分量，但会增加发送端功耗（因为峰值电流增大）。典型应用于短距离、低损耗信道。

- **去加重（De-emphasis）**：主抽头系数为1，后置抽头系数为负，前置抽头为0或很小。这种方式通过衰减非跳变符号的幅度，相对提升跳变边沿的能量比例，降低了发送端的峰值功耗，但平均信号幅度降低。广泛应用于PCIe、USB等标准。

#### 1.1.4 抽头系数优化方法

FFE抽头系数的设计可以通过以下方法获得：

- **信道逆滤波法**：根据信道的频率响应H(f)，设计FFE传递函数F(f)使得 `F(f) × H(f) ≈ 1`，即FFE与信道的级联近似全通特性。实际中通过时域脉冲响应的最小均方误差（MMSE）准则求解抽头系数。

- **零强制（Zero-Forcing）**：强制接收端采样点的ISI为零，通过求解线性方程组得到FFE系数。该方法在高SNR场景下性能最优，但可能导致噪声放大。

- **自适应算法**：在系统运行过程中，通过接收端反馈的误差信号（如眼高、BER），利用LMS（最小均方）或RLS（递归最小二乘）算法在线调整FFE系数。这种方法适用于时变信道或需要动态优化的场景。

- **查表法**：对于标准化的信道（如PCIe规范定义的参考信道），预先仿真得到一组典型的FFE系数并存储为配置表，系统初始化时根据信道类型选择对应的系数组。

### 1.2 核心特性

- **FIR滤波器结构**：采用N抽头有限冲激响应滤波器，支持灵活配置抽头数量（通常3-7抽头）和权重系数，满足不同信道损耗的补偿需求。

- **符号速率同步**：FFE工作在符号速率（Symbol Rate）时钟域，每个UI处理一个码元，抽头延迟线的间隔精确等于一个符号周期，确保ISI补偿的时间对齐精度。

- **可配置抽头系数**：抽头权重系数通过配置参数灵活设置，支持预加重、去加重、混合模式等多种均衡策略，可根据信道特性和系统需求进行优化。

- **归一化输出摆幅**：通过抽头系数的归一化或显式的增益调整，确保FFE输出信号的摆幅在合理范围内，避免后级Driver饱和或信噪比恶化。

- **低延迟特性**：FFE仅引入固定的抽头延迟（通常为半个抽头数量的UI），相比接收端DFE（需要判决反馈）具有更低的延迟和更简单的时序约束。

- **适应信道变化**：抽头系数可在运行时通过外部控制接口（如Adaption模块）动态更新，支持自适应均衡和信道追踪功能，适应温度漂移、老化等导致的信道特性变化。

### 1.3 典型应用场景

FFE在不同SerDes标准和应用中的配置要求：

| 应用标准 | 抽头数量 | 典型系数示例 | 均衡策略 | 备注 |
|---------|---------|-------------|---------|------|
| PCIe Gen3 (8Gbps) | 3-tap | [0.0, 1.0, -0.25] | 去加重 | 3.5dB或6dB去加重 |
| PCIe Gen4 (16Gbps) | 3-tap | [0.0, 1.0, -0.35] | 去加重 | 强制去加重，适配长信道 |
| USB 3.2 (10Gbps) | 3-tap | [0.0, 1.0, -0.2] | 去加重 | 可选均衡，短信道可禁用 |
| 10G/25G Ethernet | 5-tap | [0.05, 0.15, 0.6, -0.15, -0.05] | 混合 | 平衡前后游标补偿 |
| 56G SerDes (PAM4) | 7-tap | [0.02, 0.08, 0.15, 0.5, -0.15, -0.08, -0.02] | 混合 | 超长信道，配合接收端DFE |

> **注**：抽头系数归一化后应满足 `Σ|c[k]| ≈ 1`，具体数值需根据信道S参数仿真优化。

### 1.4 与其他模块的关系

- **上游：WaveGen**  
  FFE接收来自WaveGen模块的基带PRBS或自定义码型信号，输入通常为理想的NRZ或PAM-N电平（如±1V），不包含信道损耗效应。

- **下游：Mux → Driver**  
  FFE输出经过预失真处理的信号，送入Mux（多通道复用器）进行通道选择，最后由Driver放大并驱动到信道。Driver的带宽限制和非线性效应会进一步影响FFE的补偿效果，因此需要联合优化。

- **信道**  
  FFE的设计目标是预补偿信道的频率响应特性，因此其抽头系数的选择必须基于目标信道的S参数或脉冲响应进行优化。信道特性的变化（如温度、老化）可能需要动态调整FFE系数。

- **接收端均衡器（CTLE/DFE）**  
  FFE与接收端均衡器形成协同补偿关系。FFE处理低频和中频的ISI，减轻接收端负担；CTLE处理高频衰减；DFE处理残余的后游标ISI。合理的均衡预算分配可以优化系统整体的功耗和性能。

---

## 2. 模块接口

### 2.1 端口定义

FFE模块采用单端信号架构，简化建模复杂度，满足行为级仿真需求。

#### TDF域端口

| 端口名 | 方向 | 类型 | 说明 |
|-------|------|------|------|
| `in` | 输入 | double | 单端输入，接收来自WaveGen的基带信号 |
| `out` | 输出 | double | 单端输出，输出经过FFE预失真处理的信号 |

> **设计说明**：单端架构适用于行为级建模，聚焦于FIR滤波器的ISI补偿算法验证。实际硬件中FFE通常采用差分实现，但在行为仿真阶段单端建模已足够表征均衡效果。

### 2.2 参数配置

FFE模块的配置参数通过 `TxFfeParams` 结构体进行管理，定义在 `include/common/parameters.h` 中。

#### 2.2.1 基本参数结构

```cpp
struct TxFfeParams {
    std::vector<double> taps;      // FFE抽头权重系数
    
    TxFfeParams() : taps({0.2, 0.6, 0.2}) {}
};
```

#### 2.2.2 抽头系数参数 (taps)

抽头系数是FFE模块的核心配置参数，定义了FIR滤波器的时域响应特性。

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `taps` | vector&lt;double&gt; | [0.2, 0.6, 0.2] | FFE抽头权重系数数组，索引从0开始 |

**抽头含义**：
- `taps[0], taps[1], ..., taps[N-2]`：前置抽头，补偿前游标ISI（Pre-cursor）
- `taps[主抽头索引]`：主抽头，携带当前码元的主要能量，通常为最大值
- `taps[主抽头+1], ..., taps[N-1]`：后置抽头，补偿后游标ISI（Post-cursor）

**典型配置**：
- **3抽头**：`[c0, c1, c2]`，其中c1为主抽头
- **5抽头**：`[c0, c1, c2, c3, c4]`，其中c2为主抽头
- **7抽头**：`[c0, c1, c2, c3, c4, c5, c6]`，其中c3为主抽头

#### 2.2.3 抽头系数约束与验证

为确保FFE输出信号的合理性和物理可实现性，抽头系数需满足以下约束条件：

##### 归一化约束

归一化约束的具体形式取决于均衡模式：

**去加重模式（De-emphasis）**：
- 主抽头固定为1.0，后抽头为负值
- 约束条件：`c[main] = 1.0`，`Σ|c[k]| > 1.0`（后抽头"吸收"能量）
- 典型配置：`[0, 1.0, -0.2, -0.1]`（3-tap FFE）

**预加重/平衡模式（Pre-emphasis/Balanced）**：
- 所有抽头系数之和接近1.0
- 约束条件：`Σ c[k] ≈ 1.0`（保持直流增益）
- 典型配置：`[0.15, 0.7, 0.15]`（3-tap FFE）

**验证方法**：
```cpp
double sum_abs = 0.0;
double sum_algebraic = 0.0;
for (auto c : taps) {
    sum_abs += std::abs(c);
    sum_algebraic += c;
}

// 去加重模式：检查主抽头≈1.0
if (taps[main_idx] > 0.95 && taps[main_idx] < 1.05) {
    // 允许 sum_abs > 1.0
}
// 预加重/平衡模式：检查代数和≈1.0
else if (std::abs(sum_algebraic - 1.0) < 0.2) {
    // 允许 0.8 < sum_algebraic < 1.2
}
```

##### 主抽头最大原则

主抽头系数的绝对值应为所有抽头中最大的，确保主要信号能量集中在当前码元：

```
|c[main]| = max(|c[0]|, |c[1]|, ..., |c[N-1]|)
```

**典型位置**：
- 3抽头：主抽头位于索引1
- 5抽头：主抽头位于索引2
- 7抽头：主抽头位于索引3

##### 动态范围约束

单个抽头系数的绝对值不应超过1.0，避免输出饱和：

```
|c[k]| ≤ 1.0, ∀k
```

#### 2.2.4 典型应用配置示例

以下配置示例针对不同SerDes标准和信道损耗场景进行优化：

##### PCIe Gen3 (8Gbps) - 3.5dB去加重

```cpp
TxFfeParams ffe_pcie_gen3;
ffe_pcie_gen3.taps = {0.0, 1.0, -0.25};  // 去加重策略
```

**特点**：
- 主抽头归一化为1.0
- 后置抽头为负值，实现3.5dB去加重
- 前置抽头为0（无前游标补偿）
- 适用场景：PCIe短信道（<20cm背板走线）

##### PCIe Gen4/Gen5 (16Gbps/32Gbps) - 6dB去加重

```cpp
TxFfeParams ffe_pcie_gen4;
ffe_pcie_gen4.taps = {0.0, 1.0, -0.4};  // 强去加重
```

**特点**：
- 后置抽头增大到-0.4，实现6dB去加重
- 适用于更高损耗信道（20-40cm）
- 与接收端DFE协同工作

##### 10G/25G Ethernet - 平衡模式

```cpp
TxFfeParams ffe_ethernet;
ffe_ethernet.taps = {0.05, 0.2, 0.5, -0.15, -0.1};  // 5抽头
```

**特点**：
- 主抽头c[2]=0.5
- 前置抽头c[0]=0.05, c[1]=0.2提供前游标补偿
- 后置抽头c[3]=-0.15, c[4]=-0.1补偿后游标
- 归一化和：|0.05|+|0.2|+|0.5|+|0.15|+|0.1|=1.0
- 适用场景：中等损耗信道（10-15dB @ Nyquist）

##### 56G PAM4 - 长信道

```cpp
TxFfeParams ffe_pam4;
ffe_pam4.taps = {0.02, 0.08, 0.15, 0.5, -0.15, -0.1, -0.05};  // 7抽头
```

**特点**：
- 7抽头设计，主抽头c[3]=0.5
- 对称的前后游标补偿结构
- 归一化和：|0.02|+|0.08|+|0.15|+|0.5|+|0.15|+|0.1|+|0.05|=1.05
- 适用场景：超长信道（>20dB损耗），配合接收端CTLE+DFE

##### 自定义预加重模式

```cpp
TxFfeParams ffe_custom;
ffe_custom.taps = {0.15, 0.25, 0.6, -0.2, -0.1};
```

**特点**：
- 前置抽头为正值，实现预加重
- 主抽头c[2]=0.6
- 平衡前后游标补偿
- 适用于时域反射严重的信道（多次阻抗不连续）

#### 2.2.5 抽头系数优化方法论

##### 基于信道S参数的优化

**步骤1**：提取信道脉冲响应  
通过IFFT将S参数S21(f)转换为时域冲激响应h(t)：

```python
import numpy as np
from scipy.fft import ifft

# S21频域响应 → 时域脉冲响应
freq = np.array([...])  # 频率点
S21 = np.array([...])   # 复数S参数
h_t = ifft(S21)
```

**步骤2**：MMSE准则求解  
最小化接收端输出信号与期望信号之间的均方误差（MSE）：

**时域表达式**：
```
min Σ |y[n] - d[n]|²
```
其中：
- `y[n] = (h[n] ⊗ c[n])` 为信道与FFE级联后的输出
- `d[n]` 为期望的发送数据序列
- `⊗` 表示卷积运算

**频域表达式（考虑噪声功率）**：
```
H_FFE(f) = H*_channel(f) / (|H_channel(f)|² + N₀/Ps)
```
其中：
- `H*_channel(f)` 为信道频率响应的共轭
- `N₀` 为噪声功率谱密度
- `Ps` 为信号功率
- 该公式平衡了ISI消除与噪声放大的折衷

**步骤3**：归一化与量化  
将求解的抽头系数归一化到合理范围，并考虑硬件实现的量化位数（如6-bit量化）。

##### 自适应在线优化

在系统运行过程中，通过接收端反馈的误差信号（如眼高、BER估计），使用LMS算法实时调整FFE系数：

```
c[k](n+1) = c[k](n) + μ × e(n) × x(n-k)
```

其中：
- `e(n)`：接收端判决误差
- `μ`：步长参数（0.001~0.01）
- `x(n-k)`：延迟k个UI的输入信号

### 2.3 构造函数

FFE模块的构造函数遵循SystemC-AMS的标准命名规则，初始化端口和参数。

#### 构造函数签名

```cpp
class TxFfeTdf : public sca_tdf::sca_module {
public:
    // 单端输入输出端口
    sca_tdf::sca_in<double> in;
    sca_tdf::sca_out<double> out;
    
    // 构造函数
    TxFfeTdf(sc_core::sc_module_name name, const TxFfeParams& params);
    
private:
    TxFfeParams m_params;
    
    // SystemC-AMS回调函数
    void set_attributes() override;
    void initialize() override;
    void processing() override;
    
    // 内部状态：延迟线缓存
    std::vector<double> m_delay_line;
};
```

#### 构造函数实现示例

```cpp
TxFfeTdf::TxFfeTdf(sc_core::sc_module_name name, const TxFfeParams& params)
    : sca_tdf::sca_module(name)
    , in("in")
    , out("out")
    , m_params(params)
    , m_delay_line(params.taps.size(), 0.0)  // 初始化延迟线为0
{
    // 参数验证
    if (m_params.taps.empty()) {
        SC_REPORT_ERROR("TxFfeTdf", "FFE taps cannot be empty");
    }
}
```

#### 端口连接示例

在顶层测试平台或系统级模块中，FFE模块的连接方式如下：

```cpp
// 上游模块：WaveGen（单端信号源）
WaveGenTdf wave_gen("wave_gen", wave_params);

// FFE模块
TxFfeTdf tx_ffe("tx_ffe", ffe_params);

// 下游模块：Driver（单端输入）
TxDriverTdf tx_driver("tx_driver", driver_params);

// 单端信号连接
sca_tdf::sca_signal<double> sig_ffe_in, sig_ffe_out;

// 连接拓扑
wave_gen.out(sig_ffe_in);
tx_ffe.in(sig_ffe_in);
tx_ffe.out(sig_ffe_out);
tx_driver.in(sig_ffe_out);
```

> **重要提示**：SystemC-AMS要求所有端口必须连接,不允许悬空端口。

---

## 3. 核心实现机制

### 3.1 信号处理流程

FFE模块的`processing()`方法在每个符号周期（UI）执行一次FIR滤波计算，实现信号的预失真处理。

**处理流水线**：
```
输入读取 → 延迟线更新 → FIR卷积计算 → 输出写入
```

**步骤1-输入读取**：从单端输入端口`in`读取当前码元值，输入信号通常来自WaveGen模块，摆幅为±1V。

**步骤2-延迟线更新**：将当前输入码元存入抽头延迟线（`std::vector<double> m_delay_line`），采用FIFO结构，新数据从索引0进入，旧数据依次后移。

**步骤3-FIR卷积**：根据配置的抽头系数和延迟线数据执行加权求和：
```
y[n] = Σ c[k] × x[n-k]  (k=0 to N-1)
```
其中`c[k]`为抽头权重系数，`x[n-k]`为延迟k个UI的历史输入。

**步骤4-输出写入**：将FIR滤波结果写入输出端口`out`，输出信号送往下游Mux和Driver模块。

### 3.2 FIR滤波器机制

FFE采用直接形式（Direct Form）FIR滤波器结构，通过N个抽头的加权求和实现ISI预补偿。

**时域表达式**：
```
y[n] = c[0]×x[n] + c[1]×x[n-1] + ... + c[N-1]×x[n-N+1]
```

**频率响应（离散时间傅里叶变换）**：
```
H(f) = Σ c[k] × e^(-j2πfkT)  (k=0 to N-1)
```
其中`T`为符号周期（UI），`f`为频率。

**典型配置示例**（3抽头）：
- 去加重模式：`c = [0, 1.0, -0.25]`，频率响应 `H(f) = 1 - 0.25×e^(-j4πfT)`，低频增益0.75（-2.5dB），Nyquist频率增益1.25（+1.9dB）
- 平衡模式：`c = [0.15, 0.7, 0.15]`，低通特性，低频增益1.0，高频增益0.4（-7.96dB）

**延迟线管理**：采用简单的数组移位实现（抽头数通常≤7，性能开销可接受）。每个UI更新一次，延迟线在初始化时填充0值。

### 3.3 归一化与饱和处理

**归一化策略**：根据均衡模式选择是否归一化输出。去加重模式（主抽头≈1.0）通常不归一化；预加重/平衡模式可采用幅度归一化（除以`Σ|c[k]|`）保证输出峰值不超过输入摆幅。

**饱和限制**：通过硬限幅或软饱和（tanh函数）防止输出超出后级Driver的输入范围，典型饱和电平设置为Driver输入范围的80-90%。

---

## 4. 测试平台架构

### 4.1 测试平台设计思想

FFE测试平台（`FfeTransientTestbench`）采用场景驱动的模块化设计，验证FFE在不同均衡策略和信道条件下的预失真性能。核心设计理念：

1. **场景驱动**：通过枚举类型选择不同测试场景，每个场景自动配置相应的信号源和FFE抽头系数
2. **组件复用**：单端信号源、信号监控器等辅助模块可在多个测试场景间复用
3. **结果分析**：根据场景类型自动选择合适的分析方法（时域波形、频域特性）

### 4.2 测试场景定义

测试平台支持五种核心测试场景：

| 场景 | 命令行参数 | 测试目标 | 输出文件 |
|------|----------|---------|----------|
| BASIC_PRBS | `prbs` / `0` | 基本FIR滤波和抽头加权特性 | ffe_tran_prbs.csv |
| DEEMPHASIS_TEST | `deemp` / `1` | 去加重模式补偿效果 | ffe_tran_deemp.csv |
| PREEMPHASIS_TEST | `preemp` / `2` | 预加重模式高频增强 | ffe_tran_preemp.csv |
| TAP_SWEEP | `sweep` / `3` | 抽头系数扫描与优化 | ffe_tran_sweep.csv |
| CHANNEL_COMBO | `combo` / `4` | FFE+信道级联补偿验证 | ffe_tran_combo.csv |

### 4.3 场景配置详解

#### BASIC_PRBS - 基本PRBS测试

验证FFE基本的FIR滤波功能和抽头加权正确性。

- **信号源**：PRBS-7伪随机序列
- **输入幅度**：±1.0V（单端）
- **符号率**：10 Gbps
- **FFE系数**：`[0.2, 0.6, 0.2]`（3抽头平衡模式）
- **验证点**：输出波形应为输入与FIR系数的卷积结果

#### DEEMPHASIS_TEST - 去加重测试

验证去加重模式的后游标ISI预补偿能力。

- **信号源**：交替"0-1-1-1"与"1-0-0-0"码型（强制后游标ISI）
- **FFE系数**：`[0.0, 1.0, -0.35]`（PCIe Gen4典型去加重）
- **验证点**：跳变后的符号幅度应降低35%，预补偿信道的后游标衰减

#### PREEMPHASIS_TEST - 预加重测试

验证预加重模式的高频增强效果。

- **信号源**：方波（1 GHz）
- **FFE系数**：`[0.15, 0.7, 0.15]`
- **验证点**：边沿陡峭度提升，上升/下降时间缩短

#### TAP_SWEEP - 抽头扫描

通过扫描不同抽头系数组合，寻找最优均衡配置。

- **信号源**：PRBS-7
- **扫描范围**：后置抽头从-0.5到0（步长0.05）
- **固定系数**：主抽头=1.0，前置抽头=0
- **验证点**：记录每组系数对应的输出眼高/眼宽

#### CHANNEL_COMBO - 信道级联测试

验证FFE与典型信道级联后的整体补偿效果。

- **信号源**：PRBS-7
- **FFE系数**：根据信道脉冲响应优化
- **信道模型**：简化的一阶低通滤波器（模拟10dB@Nyquist损耗）
- **验证点**：级联后的眼图开口面积应大于无FFE场景

### 4.4 信号连接拓扑

测试平台的模块连接关系如下：

```
┌─────────────────┐       ┌─────────────────┐       ┌─────────────────┐
│  SignalSource   │       │    TxFfeTdf     │       │  SignalMonitor  │
│                 │       │                 │       │                 │
│  out ───────────┼───────▶ in             │       │                 │
│                 │       │                 │       │                 │
│                 │       │  out ───────────┼───────▶ in             │
└─────────────────┘       │                 │       │                 │
                          └─────────────────┘       │  → 统计分析     │
                                                     │  → CSV保存      │
                                                     └─────────────────┘
```

**可选级联（CHANNEL_COMBO场景）**：
```
SignalSource → TxFfeTdf → ChannelModel → SignalMonitor
```

### 4.5 辅助模块说明

#### SignalSource - 单端信号源

支持四种波形类型：
- **DC**：直流信号
- **SINE**：正弦波
- **SQUARE**：方波
- **PRBS**：伪随机序列（PRBS-7/15/23/31）

可配置参数：幅度、频率、符号率

#### SignalMonitor - 信号监控器

功能：
- 实时记录输入/输出波形
- 计算统计信息（均值、RMS、峰峰值）
- 输出CSV格式波形文件
- 可选：计算眼图指标（眼高、眼宽、抖动）

#### ChannelModel - 简化信道模型（CHANNEL_COMBO场景专用）

采用一阶或二阶低通滤波器模拟信道频率响应，用于快速验证FFE补偿效果。实际应用中应替换为基于S参数的精确信道模型。

### 4.6 编译与运行

测试平台代码位于 `tb/tx/ffe/` 目录（如果未创建目录结构，则位于 `tb/` 根目录），编译与运行步骤：

```bash
# 构建测试平台
cd build
cmake ..
make ffe_tran_tb

# 运行指定场景
cd tb
./ffe_tran_tb [scenario]
```

场景参数：
- `prbs` 或 `0` - 基本PRBS测试（默认）
- `deemp` 或 `1` - 去加重测试
- `preemp` 或 `2` - 预加重测试
- `sweep` 或 `3` - 抽头扫描
- `combo` 或 `4` - 信道级联测试

### 4.7 测试平台验证目标

各测试场景的核心验证指标：

| 场景 | 验证指标 | 通过标准 |
|------|---------|---------|
| BASIC_PRBS | 输出与理论卷积结果误差 | < 1% |
| DEEMPHASIS_TEST | 后游标抑制比 | 符合配置值±5% |
| PREEMPHASIS_TEST | 边沿斜率提升比 | > 1.3× |
| TAP_SWEEP | 最优系数点识别 | 眼高最大处 |
| CHANNEL_COMBO | 级联后眼高改善 | > 30% vs 无FFE |

---

## 5. 仿真结果分析

本章介绍FFE各测试场景的典型仿真结果、关键性能指标及分析方法。通过时域波形、频域特性和ISI消除效果的定量评估，验证FFE预失真功能的正确性和有效性。

### 5.1 仿真环境说明

#### 5.1.1 通用配置参数

所有测试场景共享的基础配置：

| 参数类别 | 参数名 | 典型值 | 说明 |
|---------|--------|--------|------|
| **全局仿真** | 采样率（Fs） | 100 GHz | 等于符号速率，满足离散时间FIR滤波 |
| | 仿真时长 | 10-50 ns | PRBS测试需≥2000 UI以统计 |
| | 时间步长（UI） | 10 ps | 对应10 Gbps符号率 |
| **信号源** | 输入幅度 | ±1 V | 归一化单端输入 |
| | 数据速率 | 10 Gbps | 标准测试速率 |
| | PRBS类型 | PRBS7 | 快速收敛，用于基础测试 |
| **FFE** | 抽头数量 | 3-5 | 根据场景选择 |
| | 主抽头位置 | 索引1或2 | 取决于抽头总数 |

#### 5.1.2 性能评估指标

FFE性能通过以下量化指标衡量：

| 指标 | 定义 | 计算方法 | 典型目标 |
|------|------|----------|---------|
| **眼高改善** | FFE输出相对输入的眼高提升 | (EH_out - EH_in) / EH_in | > 20% |
| **眼宽改善** | FFE输出相对输入的眼宽增加 | (EW_out - EW_in) / EW_in | > 10% |
| **ISI消除比** | 前/后游标ISI幅度降低比例 | (ISI_in - ISI_out) / ISI_in | > 50% |
| **频域增强** | 高频/低频能量比提升 | 20*log10(H(fNyq)/H(DC)) | 去加重：+3~6dB |
| **卷积误差** | 输出与理论FIR卷积的偏差 | RMS(y_meas - y_theory) / RMS(y_theory) | < 1% |

### 5.2 基础功能验证

#### 5.2.1 BASIC_PRBS测试结果

**测试配置**：
```json
{
  "signal_source": {"type": "PRBS7", "amplitude": 1.0},
  "ffe": {"taps": [0.2, 0.6, 0.2]}
}
```

**期望结果分析**：

**时域波形特征**：
- **输入信号**：PRBS7序列，电平±1V，边沿理想（无ISI）
- **输出信号**：经过3抽头FIR滤波后的波形，码元跳变处产生可见的预加重/去加重效应
  - 例如："0→1"跳变时，输出在第1个UI达到峰值（主抽头c[1]=0.6），前后各有20%的预/后游标
  - 连续"1"序列时，输出稳态值 = c[0]×1 + c[1]×1 + c[2]×1 = 1.0V（满足归一化）

**关键验证点**：

| 测试项 | 理论值 | 测量方法 | 通过标准 |
|--------|--------|----------|---------|
| 输出峰值（跳变UI） | 0.6V | 单次跳变幅度 | 误差 < 1% |
| 稳态电平（连续码） | 1.0V | 连续3个"1"的平均值 | 误差 < 1% |
| FIR卷积误差 | 0 | RMS(y_out - conv(x_in, c)) | < 1% |

**波形示意**（时域）：
```
输入码型:   0  0  1  1  1  0  0  1  0  1
            ___     ________     __  __  
输出波形:  |   |___|        |___|  ||  |___
           ↑ ↑ ↑
         前游标 主抽头 后游标
          0.2  0.6   0.2
```

#### 5.2.2 卷积正确性验证

**Python分析脚本**：
```python
import numpy as np

# 读取trace文件
data = np.loadtxt('ffe_tran_prbs.csv', delimiter=',', skiprows=1)
time = data[:, 0]
vin = data[:, 1]
vout = data[:, 2]

# FFE抽头系数
taps = np.array([0.2, 0.6, 0.2])

# 理论卷积输出
vout_theory = np.convolve(vin, taps, mode='same')

# 计算误差
rms_error = np.sqrt(np.mean((vout - vout_theory)**2)) / np.sqrt(np.mean(vout_theory**2))
print(f"卷积RMS误差: {rms_error*100:.2f}% (应 < 1%)")
```

### 5.3 去加重模式分析

#### 5.3.1 DEEMPHASIS_TEST测试结果

**测试配置**：
```json
{
  "signal_source": {"type": "pattern", "sequence": "0111_1000"},
  "ffe": {"taps": [0.0, 1.0, -0.35]}
}
```

**期望结果**：

**时域波形分析**：
- **跳变UI（n=0）**：输出幅度 = c[1]×1 = 1.0V（主抽头保持满摆幅）
- **跳变后UI（n=1）**：输出幅度 = c[1]×1 + c[2]×1 = 1.0 - 0.35 = 0.65V（去加重35%）
- **稳态UI（n≥2）**：输出幅度 = 1.0V（所有抽头对齐）

**关键测量**：

| 指标 | 理论值 | 测量方法 | 通过标准 |
|------|--------|----------|---------|
| 去加重比例 | 35% | (V_n0 - V_n1) / V_n0 | 35% ± 2% |
| 主抽头幅度 | 1.0V | 跳变UI峰值 | 误差 < 5% |
| 频域提升（@ Nyquist） | +6.35dB | \|H(fNyq)\| / \|H(DC)\| | 6.0~6.5dB |

**频域特性**：

对于3抽头FIR滤波器，频率响应为：
```
H(f) = Σ c[k] × e^(-j2πfkT)   (k=0,1,2)
```

代入抽头系数 `c = [0.0, 1.0, -0.35]`：
```
H(f) = 0 + 1.0 × e^(-j2πfT) - 0.35 × e^(-j4πfT)
```

**DC增益**（f=0）：
```
H(0) = 1.0 × e^0 - 0.35 × e^0 = 1.0 - 0.35 = 0.65
|H(0)| = 0.65 → 20log₁₀(0.65) = -3.74 dB
```

**Nyquist增益**（f = fₙ = 1/(2T)）：
```
H(fₙ) = 1.0 × e^(-jπ) - 0.35 × e^(-j2π)
      = 1.0 × (-1) - 0.35 × 1
      = -1.0 - 0.35 = -1.35
|H(fₙ)| = 1.35 → 20log₁₀(1.35) = +2.61 dB
```

**高频增强**：
```
高频增强 = |H(fₙ)|_dB - |H(0)|_dB = 2.61 - (-3.74) = 6.35 dB
```

**物理意义**：
去加重模式通过降低连续码元的幅度，相对提升跳变边沿的能量占比，预补偿信道对高频的衰减，适用于PCIe Gen3/Gen4等标准。

### 5.4 预加重模式分析

#### 5.4.1 PREEMPHASIS_TEST测试结果

**测试配置**：
```json
{
  "signal_source": {"type": "SQUARE", "frequency": 1e9},
  "ffe": {"taps": [0.15, 0.7, 0.15]}
}
```

**期望结果**：

**边沿特性**：
- **输入方波**：1GHz（跳变周期500ps），理想边沿（瞬时翻转）
- **输出波形**：边沿陡峭度提升，上升/下降时间缩短约20-30%
  - 前置抽头（c[0]=0.15）提前注入能量，预先抬升/压低电平
  - 主抽头（c[1]=0.7）携带主要能量
  - 后置抽头（c[2]=0.15）补偿后游标ISI

**测量指标**：

| 指标 | 理论 | 测量方法 | 通过标准 |
|------|------|----------|---------|
| 上升时间（10%-90%） | 减少20% | 输出/输入上升时间比 | 0.7~0.85 |
| 边沿过冲 | < 10% | (V_peak - V_final) / V_final | < 10% |
| 高频增强 | 0dB | 1GHz处增益无明显提升（平衡模式） | -3~0dB |

**频域特性**（平衡模式）：
```
H(f) = 0.15 + 0.7 + 0.15 = 1.0 (DC)
|H(fNyq)| ≈ 0.4 (低通特性)
```

**应用场景**：
平衡模式适用于信道反射严重的场景，通过对称的前后游标补偿，同时抑制前游标ISI（反射导致）和后游标ISI（色散导致）。

### 5.5 抽头扫描优化

#### 5.5.1 TAP_SWEEP测试结果

**测试配置**：
- 固定前置抽头：c[0] = 0
- 固定主抽头：c[1] = 1.0
- 扫描后置抽头：c[2] = -0.5 ~ 0（步长0.05）
- 信号源：PRBS7

**典型结果示意**：

| c[2] | 眼高(V) | 眼宽(ps) | ISI(mV) | 评分 |
|------|---------|----------|---------|------|
| 0.0  | 0.85    | 75       | 45      | 基准 |
| -0.1 | 0.90    | 78       | 35      | ↑ |
| -0.2 | 0.93    | 80       | 28      | ↑↑ |
| -0.3 | 0.95    | 81       | 22      | 最优 |
| -0.4 | 0.92    | 78       | 25      | ↓ |
| -0.5 | 0.87    | 72       | 38      | ↓↓ |

**分析结论**：
- **最优系数**：c[2] ≈ -0.3，此时眼高最大、ISI最小
- **欠补偿（c[2] > -0.3）**：后游标ISI残留，眼高降低
- **过补偿（c[2] < -0.3）**：引入新的预失真误差，反而恶化信号质量

**优化建议**：
实际应用中，通过类似的扫描方法（结合信道S参数仿真），可快速找到最优FFE系数组合，平衡ISI消除与噪声放大的折衷。

### 5.6 信道级联验证

#### 5.6.1 CHANNEL_COMBO测试结果

**测试配置**：
```
SignalSource → TxFfeTdf → ChannelModel → Measurement
```
- 信道模型：一阶低通滤波器，-3dB @ 5GHz（模拟10dB@Nyquist损耗）
- FFE系数：通过信道脉冲响应优化，例如 [0.05, 0.8, -0.25]

**对比实验**：

| 配置 | 输入眼高 | 输出眼高 | 眼高改善 | 眼宽改善 |
|------|---------|---------|---------|---------|
| 无FFE | 2.0V | 1.2V | — | — |
| 启用FFE | 2.0V | 1.65V | +37.5% | +15% |

**结论**：
FFE将信道输出的眼高从1.2V提升至1.65V，改善37.5%，证明预失真有效补偿了信道的频率选择性衰减，降低了接收端均衡器（CTLE/DFE）的压力。

### 5.7 波形数据文件格式

CSV输出格式：
```
时间(s),输入信号(V),输出信号(V)
0.000000e+00,0.000000,0.000000
1.000000e-11,1.000000,0.600000
2.000000e-11,1.000000,1.000000
...
```

采样点数 = 仿真时长 / UI（例如50ns / 10ps = 5000点）。

---

## 7. 技术要点

### 7.1 单端架构的设计权衡

**设计决策**：FFE采用单端信号架构进行行为级建模，而非差分架构。

**理由**：
- **建模简化**：单端架构聚焦于FIR滤波器的核心算法验证，避免差分信号建模带来的额外复杂度（共模抑制、增益失配、相位偏斜等）
- **仿真效率**：减少端口数量和信号路径，降低SystemC-AMS仿真的计算开销（单端比差分减少约40%端口连接）
- **算法通用性**：ISI预补偿的FIR卷积算法本质上是标量运算，单端建模已足够表征均衡效果

**实际硬件对应**：
- 实际SerDes中的FFE通常采用差分实现（差分对驱动、差分延迟线）
- 单端行为模型的验证结果可直接映射到差分硬件（差分信号可视为两路单端信号的线性组合）
- 如需评估差分特有的非理想效应（如共模噪声、失配），可在后续设计阶段扩展为差分架构

### 7.2 符号速率处理的关键约束

**设计特点**：FFE工作在符号速率（Symbol Rate）时钟域，每个UI处理一次。

**时序约束**：
- 抽头延迟线的时间间隔必须精确等于一个符号周期（UI）
- SystemC-AMS的采样率设置：`set_rate(symbol_rate)`
- 时间步长误差会累积导致ISI补偿失准，建议时间分辨率 ≤ UI/1000

**与其他模块的时钟域关系**：
- **上游WaveGen**：必须同步于相同符号率，确保每个UI输出一个码元
- **下游Driver**：可工作在更高采样率（过采样模式），通过插值器桥接
- **跨时钟域风险**：如WaveGen与FFE采样率不匹配，会导致码元错位或重复采样

**调试建议**：
- 使用trace文件验证输入/输出码元时间戳严格对齐
- 检查延迟线缓存大小与抽头数量一致：`m_delay_line.size() == m_params.taps.size()`

### 7.3 归一化策略选择

**核心问题**：如何确保FFE输出信号摆幅在合理范围，避免后级Driver饱和或信噪比恶化？

**三种归一化策略**：

**策略1 - 绝对值归一化**：
```
归一化因子 = 1.0 / Σ|c[k]|
输出 = (Σ c[k] × x[n-k]) × 归一化因子
```
- 优点：保证输出峰值不超过输入峰值，适合预加重/平衡模式
- 缺点：去加重模式下会降低主抽头幅度（失去去加重定义的物理意义）

**策略2 - 主抽头归一化（推荐用于去加重）**：
```
主抽头固定为1.0，后抽头为负值
无需额外归一化，保持去加重比例定义的直观性
```
- 优点：符合PCIe/USB等标准的去加重定义（如3.5dB/6dB de-emphasis）
- 缺点：输出峰值可能略超输入（当后抽头较大时）

**策略3 - 无归一化（需后级增益调整）**：
```
直接输出FIR卷积结果，由下游Driver的dc_gain参数统一调整
```
- 优点：最大灵活性，可根据信道特性动态调整整体链路增益
- 缺点：需要精细的系统级增益预算管理

**推荐配置准则**：
- 去加重模式：采用策略2，主抽头=1.0
- 预加重/平衡模式：采用策略1或策略3，结合Driver增益联合优化

### 7.4 抽头数量与性能的折衷

**抽头数量选择依据**：

| 信道损耗(@Nyquist) | 推荐抽头数 | 典型应用 | 补偿能力 |
|------------------|----------|---------|---------|
| < 6dB | 3-tap | PCIe Gen3短信道 | 基础后游标补偿 |
| 6-12dB | 5-tap | 10G/25G Ethernet | 平衡前后游标ISI |
| 12-20dB | 7-tap | 56G PAM4中距离 | 扩展ISI范围 |
| > 20dB | 9-tap及以上 | 112G超长信道 | 需配合接收端DFE |

**计算复杂度**：
- FIR滤波器计算量：O(N)每符号，N为抽头数
- 延迟线更新：O(N)内存移位
- 对于N≤7的典型配置，计算开销可忽略

**边际收益递减**：
- 3→5抽头：眼高改善显著（典型+30%）
- 5→7抽头：眼高改善中等（典型+15%）
- 7→9抽头：眼高改善有限（典型+5%），且引入更多噪声放大

**设计建议**：
- 短距离应用（<10cm PCB）：3-tap足够
- 标准应用（10-30cm背板）：5-tap平衡性能与复杂度
- 极端应用（>40cm或高速率）：7-tap，需配合CTLE/DFE协同优化

### 7.5 FFE与接收端均衡器的协同优化

**均衡预算分配原则**：

SerDes链路的总ISI补偿需求应在TX FFE、RX CTLE、RX DFE之间合理分配：

**TX FFE的优势与局限**：
- ✅ 优势：预补偿不放大接收端噪声，改善接收端SNR
- ✅ 优势：降低接收端均衡器功耗（CTLE/DFE可采用更低增益）
- ❌ 局限：仅能补偿静态或慢变信道特性，无法追踪快速变化
- ❌ 局限：发送端功耗增加（峰值电流上升，Driver设计复杂）

**CTLE的优势与局限**：
- ✅ 优势：连续时间均衡，补偿高频衰减，无符号间干扰累积
- ✅ 优势：可动态调整增益，适应信道变化
- ❌ 局限：零极点设计有限，难以精确匹配复杂信道响应
- ❌ 局限：高频增益放大噪声，SNR恶化

**DFE的优势与局限**：
- ✅ 优势：精确消除后游标ISI，不放大噪声
- ✅ 优势：适应性强，可通过LMS算法在线优化
- ❌ 局限：判决反馈延迟限制速率（首抽头必须在1 UI内完成）
- ❌ 局限：错误传播风险（前一判决错误影响后续抽头）

**协同优化策略**：

| 场景 | FFE策略 | CTLE策略 | DFE策略 | 理由 |
|------|---------|---------|---------|------|
| 低损耗信道(<6dB) | 轻度去加重(3-tap) | 低增益或禁用 | 1-2抽头DFE | 避免过度均衡放大噪声 |
| 中等损耗(6-12dB) | 中度预加重(5-tap) | 中等增益CTLE | 3-5抽头DFE | 平衡分配，各自承担部分ISI |
| 高损耗(>12dB) | 强预加重(7-tap) | 高增益CTLE | 5-8抽头DFE | 最大化利用所有均衡手段 |

**设计流程建议**：
1. 通过信道脉冲响应分析，确定总ISI能量分布（前游标vs后游标）
2. 优先使用FFE补偿后游标ISI（TX端预补偿SNR最优）
3. CTLE补偿高频衰减（零极点匹配信道斜率）
4. DFE处理残余后游标ISI和非线性效应

### 7.6 抽头系数的动态更新机制

**静态配置 vs 动态自适应**：

**静态配置**（当前实现）：
- 抽头系数在仿真/系统初始化时加载，运行期间固定
- 适用场景：信道特性已知且稳定（实验室测试、标准信道模型）
- 优点：简单可靠，无收敛时间开销
- 缺点：无法适应温度漂移、老化、负载变化

**动态自适应**（扩展功能）：
- 通过接收端反馈（如眼高监测、BER估计），实时调整FFE系数
- 常用算法：LMS（最小均方）、RLS（递归最小二乘）
- 收敛时间：通常1000-10000 UI
- 实现复杂度：需要DE-TDF桥接模块传递反馈信号

**如何在当前架构中扩展自适应功能**：
1. 添加控制端口：`sca_de::sca_in<std::vector<double>> tap_update`
2. 在`processing()`中检测更新事件：`if (tap_update.event()) { m_taps = tap_update.read(); }`
3. 连接Adaption模块（DE域，实现LMS算法）与FFE的控制端口

### 7.7 参数验证与边界条件处理

**核心验证规则**：

**规则1 - 非空验证**：
```cpp
if (m_params.taps.empty()) {
    SC_REPORT_ERROR("TxFfeTdf", "FFE taps cannot be empty");
}
```

**规则2 - 主抽头识别**：
```cpp
auto max_it = std::max_element(taps.begin(), taps.end(), 
    [](double a, double b) { return std::abs(a) < std::abs(b); });
size_t main_idx = std::distance(taps.begin(), max_it);
```

**规则3 - 动态范围检查**：
```cpp
for (auto c : taps) {
    if (std::abs(c) > 1.0) {
        SC_REPORT_WARNING("TxFfeTdf", "Tap coefficient exceeds 1.0, may cause saturation");
    }
}
```

**边界条件处理**：
- **初始化阶段**：延迟线填充0值，前N-1个输出码元会有启动瞬态（可通过预填充历史数据消除）
- **抽头系数为0**：自动跳过计算，优化性能
- **单抽头模式**（N=1）：退化为简单增益调整，无ISI补偿效果

### 7.8 仿真性能优化技巧

**优化1 - 延迟线实现选择**：
- 简单数组移位：`std::rotate(delay_line.begin(), delay_line.begin()+1, delay_line.end())`
- 循环缓冲区：避免移位，通过索引环绕实现O(1)更新
- 推荐：抽头数≤5时用数组移位（代码简洁），>5时用循环缓冲区

**优化2 - 条件执行**：
```cpp
// 跳过系数为0的抽头
for (size_t i = 0; i < taps.size(); ++i) {
    if (std::abs(taps[i]) < 1e-10) continue;  // 避免无效计算
    output += taps[i] * delay_line[i];
}
```

**优化3 - 向量化计算**（需编译器支持）：
```cpp
// 使用SIMD指令加速FIR卷积
output = std::inner_product(taps.begin(), taps.end(), delay_line.begin(), 0.0);
```

**优化4 - 减少trace开销**：
- 仅在需要波形分析时启用trace
- 使用抽样trace（如每10个UI记录一次）降低文件大小

---

## 6. 运行指南

### 6.1 环境配置

运行测试前需要配置SystemC和SystemC-AMS环境变量：

```bash
export SYSTEMC_HOME=/usr/local/systemc-2.3.4
export SYSTEMC_AMS_HOME=/usr/local/systemc-ams-2.3.4
source scripts/setup_env.sh
```

### 6.2 构建与运行

#### 使用CMake（推荐）

```bash
# 进入构建目录
cd build
cmake ..
make ffe_tran_tb

# 运行测试平台
cd tb
./ffe_tran_tb [scenario]
```

#### 使用Makefile

```bash
# 构建FFE测试平台
make ffe_tran_tb

# 运行指定场景
cd tb
./ffe_tran_tb [scenario]
```

场景参数：
- `prbs` 或 `0` - 基本PRBS测试（默认）
- `deemp` 或 `1` - 去加重测试
- `preemp` 或 `2` - 预加重测试
- `sweep` 或 `3` - 抽头扫描
- `combo` 或 `4` - 信道级联测试

### 6.3 配置文件管理

FFE模块的参数通过JSON配置文件管理，典型配置位于 `config/` 目录：

```json
{
  "tx": {
    "ffe": {
      "taps": [0.0, 1.0, -0.35]
    }
  }
}
```

修改配置后需重新构建测试平台以使配置生效。

### 6.4 结果查看

测试完成后，波形数据保存到CSV文件（`ffe_tran_*.csv`）。使用Python脚本进行可视化：

```bash
# 绘制时域波形
python scripts/plot_ffe_waveform.py

# 频域分析（需scipy）
python scripts/analyze_ffe_frequency.py
```

控制台输出关键统计指标：
- 输出峰峰值
- 卷积误差（BASIC_PRBS场景）
- 去加重比例（DEEMPHASIS_TEST场景）
- 最优抽头系数（TAP_SWEEP场景）

---

## 8. 参考信息

### 8.1 相关文件

| 文件类型 | 路径 | 说明 |
|---------|------|------|
| 参数定义 | `include/common/parameters.h` | TxFfeParams 结构体 |
| 头文件 | `include/ams/tx_ffe.h` | TxFfeTdf 类声明 |
| 实现文件 | `src/ams/tx_ffe.cpp` | TxFfeTdf 类实现 |
| 测试平台 | `tb/tx/ffe/ffe_tran_tb.cpp` | 瞬态仿真测试平台（待实现） |
| 测试辅助 | `tb/tx/ffe/ffe_helpers.h` | 信号源和监控器（待实现） |
| 单元测试 | `tests/unit/test_ffe_basic.cpp` | GoogleTest 单元测试（待实现） |
| 波形绘图 | `scripts/plot_ffe_waveform.py` | Python 可视化脚本（待实现） |

### 8.2 相关模块文档

| 模块 | 文档路径 | 关联关系 |
|------|---------|---------|
| WaveGen | `/docs/modules/waveGen.md` | 上游模块，提供PRBS数据源 |
| TX Mux | `/docs/modules/mux.md` | 下游模块，接收FFE输出 |
| TX Driver | `/docs/modules/driver.md` | TX链路末端，最终输出到信道 |
| Channel | `/docs/modules/channel.md` | 信道特性决定FFE系数设置 |
| RX CTLE | `/docs/modules/ctle.md` | 接收端均衡器，与FFE协同工作 |
| RX DFE | `/docs/modules/dfesummer.md` | 接收端反馈均衡器 |

### 8.3 依赖项

**编译时依赖**：
- SystemC 2.3.4
- SystemC-AMS 2.3.4
- C++14 标准

**测试依赖**：
- GoogleTest 1.12.1（单元测试）
- NumPy/SciPy（Python 分析工具）
- Matplotlib（波形绘图）

### 8.4 相关标准与规范

| 标准 | 版本 | 相关内容 |
|------|------|---------|
| IEEE 802.3 | 2018 | 以太网FFE规范（100GBASE-KR4等） |
| PCIe | Gen 4/5/6 | 发送端预加重要求（TX Preset） |
| USB4 | v2.0 | FFE系数范围和步长定义 |
| OIF CEI | 56G/112G | 常见均衡器模板（Template） |

### 8.5 配置示例

#### 基本配置（3抽头FFE）

```json
{
  "tx": {
    "ffe": {
      "taps": [0.0, 1.0, -0.35],
      "enable": true
    }
  }
}
```

**参数说明**：
- `taps[0] = 0.0`：无前置抽头
- `taps[1] = 1.0`：主抽头（归一化）
- `taps[2] = -0.35`：第一后置抽头（35%去加重）

#### 高损耗信道配置（5抽头）

```json
{
  "tx": {
    "ffe": {
      "taps": [-0.05, 0.1, 1.0, -0.4, -0.15],
      "enable": true
    }
  }
}
```

**应用场景**：
- 背板信道（>30dB插损@Nyquist频率）
- 长电缆链路
- 需要强预补偿的场景

#### 预加重配置

```json
{
  "tx": {
    "ffe": {
      "taps": [-0.2, 1.0, 0.0],
      "enable": true
    }
  }
}
```

**应用场景**：
- 补偿信道的前游标ISI
- 特殊的反射或谐振特性

### 8.6 学术参考

**FIR滤波器理论**：
- Alan V. Oppenheim, *Discrete-Time Signal Processing*, 3rd Edition
- 第6章：离散时间系统的频率响应

**均衡技术**：
- S. Gondi and B. Razavi, "Equalization and Clock Recovery for a 2.5-10 Gb/s 2-PAM/4-PAM Backplane Transceiver", IEEE JSSC 2009
- A. Emami-Neyestanak et al., "A 6 Gb/s Voltage-Mode Transmitter", IEEE JSSC 2007

**SystemC-AMS建模**：
- *SystemC AMS User's Guide*, Accellera, Version 2.3
- 第4章：TDF（Timed Data Flow）建模方法

### 8.7 外部资源

- **Accellera官网**：https://systemc.org/（SystemC-AMS标准下载）
- **SerDes设计指南**：Xilinx UG476, Altera AN 529（商用FPGA SerDes设计参考）
- **IBIS-AMI建模**：IBIS Open Forum（行为级建模标准，与本模块互补）

---

**文档版本**：v0.1  
**最后更新**：2026-01-13  
**作者**：Yizhe Liu

---