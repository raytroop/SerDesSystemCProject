/**
 * @file test_channel_sparam_config.cpp
 * @brief Unit tests for ChannelSParamTdf configuration loading
 * 
 * Tests verify that C++ implementation correctly loads and parses
 * configuration generated by Python preprocessing script.
 */

#include <gtest/gtest.h>
#include <fstream>
#include <cmath>

#include "common/parameters.h"
#include "ams/channel_sparam.h"
#include "../third_party/json.hpp"

namespace serdes {
namespace test {

// Path to test configuration file (generated by Python)
// Use path relative to source root (tests run from build directory)
static const char* TEST_CONFIG_PATH = 
    "../tests/data/peters_test_config.json";

/**
 * Test fixture for config loading tests
 */
class ChannelConfigLoadTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Check if test config file exists
        std::ifstream f(TEST_CONFIG_PATH);
        config_exists_ = f.good();
        f.close();
    }
    
    bool config_exists_ = false;
};

/**
 * Test that config file exists
 */
TEST_F(ChannelConfigLoadTest, ConfigFileExists) {
    ASSERT_TRUE(config_exists_) 
        << "Test config file not found: " << TEST_CONFIG_PATH
        << "\nRun: python scripts/process_sparam.py to generate it";
}

/**
 * Test JSON parsing of config file
 */
TEST_F(ChannelConfigLoadTest, ParseJsonConfig) {
    if (!config_exists_) {
        GTEST_SKIP() << "Config file not available";
    }
    
    std::ifstream file(TEST_CONFIG_PATH);
    ASSERT_TRUE(file.is_open());
    
    std::stringstream buffer;
    buffer << file.rdbuf();
    
    try {
        auto config = nlohmann::json::parse(buffer.str());
        
        // Check required fields
        EXPECT_TRUE(config.contains("version"));
        EXPECT_TRUE(config.contains("fs"));
        EXPECT_TRUE(config.contains("method"));
        
        // Check fs value
        double fs = config["fs"].get<double>();
        EXPECT_DOUBLE_EQ(fs, 100e9);
        
        // Check filters or impulse_responses exist
        bool has_filters = config.contains("filters") && !config["filters"].empty();
        bool has_ir = config.contains("impulse_responses") && !config["impulse_responses"].empty();
        EXPECT_TRUE(has_filters || has_ir);
        
    } catch (const std::exception& e) {
        FAIL() << "JSON parsing failed: " << e.what();
    }
}

/**
 * Test loading S21 filter data
 */
TEST_F(ChannelConfigLoadTest, LoadS21FilterData) {
    if (!config_exists_) {
        GTEST_SKIP() << "Config file not available";
    }
    
    std::ifstream file(TEST_CONFIG_PATH);
    auto config = nlohmann::json::parse(file);
    
    ASSERT_TRUE(config.contains("filters"));
    ASSERT_TRUE(config["filters"].contains("S21"));
    
    auto& s21 = config["filters"]["S21"];
    
    // Check filter has required fields
    EXPECT_TRUE(s21.contains("num"));
    EXPECT_TRUE(s21.contains("den"));
    EXPECT_TRUE(s21.contains("order"));
    EXPECT_TRUE(s21.contains("dc_gain"));
    EXPECT_TRUE(s21.contains("mse"));
    
    // Validate order
    int order = s21["order"].get<int>();
    EXPECT_EQ(order, 12);
    
    // Validate DC gain is reasonable (between 0 and 2 for S21)
    double dc_gain = s21["dc_gain"].get<double>();
    EXPECT_GT(dc_gain, 0.0);
    EXPECT_LT(dc_gain, 2.0);
    
    // Validate MSE is small
    double mse = s21["mse"].get<double>();
    EXPECT_LT(mse, 1e-2);  // MSE should be < 1%
    
    // Validate coefficient arrays have correct size
    auto& num = s21["num"];
    auto& den = s21["den"];
    EXPECT_EQ(num.size(), order + 1);
    EXPECT_EQ(den.size(), order + 1);
    
    // Den[0] should be 1.0 (normalized)
    EXPECT_DOUBLE_EQ(den[0].get<double>(), 1.0);
}

/**
 * Test loading S21 impulse response data
 */
TEST_F(ChannelConfigLoadTest, LoadS21ImpulseData) {
    if (!config_exists_) {
        GTEST_SKIP() << "Config file not available";
    }
    
    std::ifstream file(TEST_CONFIG_PATH);
    auto config = nlohmann::json::parse(file);
    
    ASSERT_TRUE(config.contains("impulse_responses"));
    ASSERT_TRUE(config["impulse_responses"].contains("S21"));
    
    auto& s21_ir = config["impulse_responses"]["S21"];
    
    // Check required fields
    EXPECT_TRUE(s21_ir.contains("impulse"));
    EXPECT_TRUE(s21_ir.contains("length"));
    EXPECT_TRUE(s21_ir.contains("dt"));
    EXPECT_TRUE(s21_ir.contains("energy"));
    EXPECT_TRUE(s21_ir.contains("peak_time"));
    
    // Validate length
    int length = s21_ir["length"].get<int>();
    EXPECT_GT(length, 0);
    EXPECT_LE(length, 8192);
    
    // Validate dt matches fs
    double dt = s21_ir["dt"].get<double>();
    double fs = config["fs"].get<double>();
    EXPECT_NEAR(dt, 1.0 / fs, 1e-15);
    
    // Validate impulse array size matches length
    auto& impulse = s21_ir["impulse"];
    EXPECT_EQ(impulse.size(), length);
    
    // Validate peak_time is reasonable (for ~4ns delay channel)
    double peak_time = s21_ir["peak_time"].get<double>();
    EXPECT_GT(peak_time, 3e-9);   // > 3 ns
    EXPECT_LT(peak_time, 6e-9);   // < 6 ns
}

/**
 * Test DC gain consistency between VF and IR methods
 * This verifies the Python preprocessing produced consistent results
 */
TEST_F(ChannelConfigLoadTest, DCGainConsistency) {
    if (!config_exists_) {
        GTEST_SKIP() << "Config file not available";
    }
    
    std::ifstream file(TEST_CONFIG_PATH);
    auto config = nlohmann::json::parse(file);
    
    // Get VF DC gain
    double vf_dc_gain = config["filters"]["S21"]["dc_gain"].get<double>();
    
    // Calculate IR DC gain from impulse sum
    auto& impulse = config["impulse_responses"]["S21"]["impulse"];
    double ir_sum = 0.0;
    for (auto& v : impulse) {
        ir_sum += v.get<double>();
    }
    
    // DC gain from impulse = sum(h) for discrete-time
    double ir_dc_gain = ir_sum;
    
    // Check consistency (allow 5% difference due to method differences)
    double diff_pct = std::abs(vf_dc_gain - ir_dc_gain) / ir_dc_gain * 100.0;
    EXPECT_LT(diff_pct, 5.0) 
        << "VF DC=" << vf_dc_gain << ", IR DC=" << ir_dc_gain;
}

} // namespace test
} // namespace serdes
