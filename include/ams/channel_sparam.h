#ifndef SERDES_CHANNEL_SPARAM_H
#define SERDES_CHANNEL_SPARAM_H

#include <systemc-ams>
#include "common/parameters.h"
#include <vector>
#include <string>
#include <memory>
#include <deque>

namespace serdes {

/**
 * Channel modeling method enumeration
 */
enum class ChannelMethod {
    SIMPLE,      // Simple low-pass filter (default, v0.4 compatible)
    RATIONAL,    // Rational function fitting (sca_ltf_nd)
    IMPULSE      // Impulse response convolution
};

/**
 * Extended channel parameters for S-parameter based modeling
 */
struct ChannelExtendedParams {
    // Method selection
    ChannelMethod method = ChannelMethod::SIMPLE;
    
    // Configuration file path (JSON from Python preprocessing)
    std::string config_file;
    
    // Rational fitting parameters
    struct RationalParams {
        int order = 8;
        bool enforce_stable = true;
        bool enforce_passive = true;
    } rational;
    
    // Impulse response parameters
    struct ImpulseParams {
        int time_samples = 4096;
        bool causality = true;
        double truncate_threshold = 1e-6;
        bool use_fft = false;           // Use FFT convolution for long impulse
        int fft_threshold = 512;        // Switch to FFT when L > threshold
    } impulse;
    
    // Sampling rate (from global or config)
    double fs = 100e9;
};

/**
 * Rational function filter data loaded from config
 */
struct RationalFilterData {
    std::vector<double> num_coeffs;     // Numerator coefficients [b0, b1, ..., bn]
    std::vector<double> den_coeffs;     // Denominator coefficients [1, a1, ..., am]
    int order = 0;
    double dc_gain = 1.0;
    double mse = 0.0;
};

/**
 * Impulse response data loaded from config
 */
struct ImpulseResponseData {
    std::vector<double> time;           // Time array
    std::vector<double> impulse;        // Impulse response values
    int length = 0;
    double dt = 0.0;
    double energy = 0.0;
    double peak_time = 0.0;
};

/**
 * Channel S-parameter TDF Module
 * 
 * Implements channel modeling using S-parameter data with two methods:
 * 1. Rational function fitting (LTF filter)
 * 2. Impulse response convolution
 * 
 * The module reads configuration from a JSON file generated by the
 * Python preprocessing script (process_sparam.py).
 */
class ChannelSParamTdf : public sca_tdf::sca_module {
public:
    // TDF ports
    sca_tdf::sca_in<double> in;
    sca_tdf::sca_out<double> out;
    
    /**
     * Constructor with basic parameters (v0.4 compatible)
     * @param nm Module name
     * @param params Basic channel parameters
     */
    ChannelSParamTdf(sc_core::sc_module_name nm, const ChannelParams& params);
    
    /**
     * Constructor with extended parameters
     * @param nm Module name
     * @param params Basic channel parameters
     * @param ext_params Extended parameters for S-param modeling
     */
    ChannelSParamTdf(sc_core::sc_module_name nm, 
                     const ChannelParams& params,
                     const ChannelExtendedParams& ext_params);
    
    /**
     * Destructor
     */
    ~ChannelSParamTdf();
    
    // SystemC-AMS lifecycle methods
    void set_attributes() override;
    void initialize() override;
    void processing() override;
    
    /**
     * Load configuration from JSON file
     * @param config_path Path to JSON configuration file
     * @return true if successful
     */
    bool load_config(const std::string& config_path);
    
    /**
     * Get current channel method
     */
    ChannelMethod get_method() const { return m_ext_params.method; }
    
    /**
     * Get DC gain of the channel
     */
    double get_dc_gain() const;

private:
    // Parameters
    ChannelParams m_params;
    ChannelExtendedParams m_ext_params;
    
    // Simple model state (v0.4)
    double m_filter_state;
    double m_alpha;
    
    // Rational function method state
    RationalFilterData m_rational_data;
    sca_tdf::sca_ltf_nd m_ltf_num;      // LTF numerator
    sca_tdf::sca_ltf_nd m_ltf_den;      // LTF denominator
    sca_util::sca_vector<double> m_num_vec;
    sca_util::sca_vector<double> m_den_vec;
    double m_ltf_state;                  // Internal state for LTF
    
    // Impulse response method state
    ImpulseResponseData m_impulse_data;
    std::vector<double> m_delay_line;    // Circular buffer for input history
    int m_delay_idx;                     // Current position in delay line
    
    // FFT convolution state (for long impulse responses)
    bool m_use_fft;
    int m_fft_size;
    int m_block_size;
    std::vector<double> m_input_block;
    std::vector<double> m_H_fft_real;    // Pre-computed FFT of impulse (real)
    std::vector<double> m_H_fft_imag;    // Pre-computed FFT of impulse (imag)
    std::deque<double> m_output_queue;
    int m_block_idx;
    
    // Initialization flags
    bool m_config_loaded;
    bool m_initialized;
    
    // Private methods
    void init_simple_model();
    void init_rational_model();
    void init_impulse_model();
    
    double process_simple(double x);
    double process_rational(double x);
    double process_impulse(double x);
    double process_impulse_fft(double x);
    
    // JSON parsing helpers
    bool parse_json_config(const std::string& json_content);
    bool parse_rational_filter(const std::string& name, const void* json_obj);
    bool parse_impulse_response(const std::string& name, const void* json_obj);
    
    // FFT helpers
    void init_fft_convolution();
    void fft_real(const std::vector<double>& in, 
                  std::vector<double>& out_real, 
                  std::vector<double>& out_imag);
    void ifft_real(const std::vector<double>& in_real,
                   const std::vector<double>& in_imag,
                   std::vector<double>& out);
};

} // namespace serdes

#endif // SERDES_CHANNEL_SPARAM_H
